{"posts":[{"title":"不要被低价蒙蔽了双眼，3分钟教你如何判断中转站的实际价格","content":"背景 首先感谢这个帖子开启了一个很有意思的话题，那就是中转站的价格是否是和他们宣传的一样便宜。https://linux.do/t/topic/459160 结论 凑巧这周二我也手动算了一圈27个中转站的实际价格。找到一些很有意思的结论： 大部分中转站的价格都非常乱，一般来说都是 有错有对的模型倍率 + 五花八门的分组倍率 + 充值汇率 有些商用中转站默认的模型价格就是错的，只要用默认就有问题，最明显的就是o1-mini / o3-mini 这两个，很多站点的价格是 1.5 倍，比官方定价贵大约3倍。 在发现问题后，可以尝试和商家进行沟通，一般来说小错误应该得到修正。商家不及时修正的后果可能是被挂在论坛上吊着打。https://linux.do/t/topic/366740 对于所有看到的帖子的中转站维护者，从简便计算和做大做强的角度应该这样做： 将自己的模型倍率对齐官方的价格。 价格波动可以依靠不同的分组倍率来调节。 充值汇率固定为1:1。 经验分享 计算公式 中转站的实际价格 = (模型倍率/官方标准倍率) * (分组倍率，没有就是1) * 充值汇率 举个例子，假如有一个叫 FakeAI 的中转站，他的充值汇率是1块钱等于1美元额度，o1-mini 模型倍率是 1.5倍且补全倍率和官方一致是4倍，分组&quot;官转&quot;的分组倍率是 2x。 那么对于 o1-mini 模型实际的价格就是 (1.5/0.55) * 2 * 1 = 5.45。也就是充值 5.45 元才能获得这个模型官方 1 美元的额度。 注：0.55是 o1-mini 模型的官方倍率，具体推算规则在下面。 关于模型倍率的概念 因为几乎所有的中转站都是 one-api 的某种分支。所以他们都集成了模型倍率这个屎山概念。 在早期，因为可以注册账号试用5美元 OpenAI 的 api额度，但有rpm的严格限制。刚开发的 one-api 很大一个功能就是把一堆试用账号攒起来混在一起用。 那时候的模型是 davinci-002。这个模型输入 1M tokens的价格是 $2.00，输出 1M tokens 的价格 $2.00。 one-api 基于某种简便计算的需要(？)，创造了一个模型倍率的概念，设定1倍的模型倍率和 davinci-002 的输入输出价格一致。即 1M tokens 的价格为 $2.00。 相关讨论可以看这里：https://github.com/songquanpeng/one-api/issues/766 热门模型的倍率 几个热门模型的标准倍率应该是这样的： 模型 模型倍率 提示倍率 补全倍率 gpt-4o-mini 0.075 1 4 gpt-4o 1.25 1 4 o1-mini 0.55 1 4 claude-3.5-sonnet 1.5 1 5 deepseek-r1 0.275 1 4 如何计算我用的模型的标准倍率应该是多少？ 我们以高峰期的 deepseek r1 模型为例。以美元计价，在未命中缓存时输入 1M tokens的价格是 $0.55，输出 1M tokens的价格是 $2.19。 那么，deepseek r1的模型倍率 = deepseek-r1输入价格 $0.55 / davinci-002的输入价格 $2 = 0.275倍。 这个时候我们会注意到 输出 token 的价格比输入贵很多，那么输出比输入贵多少倍，就是补全倍率。 补全倍率 = deepseek-r1输入价格 $0.55 / deepseek-r1输出价格 $2.19 = 4倍。 来源：https://api-docs.deepseek.com/quick_start/pricing 我手动计算后27个中转站的实际价格 可以看这个：中转站竞技场 ","link":"https://www.yiios.com/post/bu-yao-bei-di-jie-meng-bi-liao-shuang-yan-3-fen-zhong-jiao-ni-ru-he-pan-duan-zhong-zhuan-zhan-de-shi-ji-jie-ge/"},{"title":"计算 nodeseek 论坛签到获得鸡腿的平均值","content":"获取了当天总计1903条签到数据，总鸡腿数量为9425，平均值为4.952706253。 以收集到的数据来说，略亏一丢丢。直接+5是最稳妥、长期收益最高的。 作案工具如下，复制到浏览器控制台中使用： function sleep(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms)); } async function fetchData(page) { const url = `https://www.nodeseek.com/api/attendance/board?page=${page}`; const response = await fetch(url); if (response.ok) { return response.json(); } else { return null; } } function convertToCSV(data) { const header = [&quot;id&quot;, &quot;member_id&quot;, &quot;day_id&quot;, &quot;gain&quot;, &quot;created_at&quot;, &quot;member_name&quot;]; const rows = data.map(item =&gt; [ item['id'], item['member_id'], item['day_id'], item['gain'], item['created_at'], item['member_name'] ]); const csvContent = [header, ...rows].map(e =&gt; e.join(&quot;,&quot;)).join(&quot;\\n&quot;); return csvContent; } function downloadCSV(csvContent, filename = 'attendance_data.csv') { const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const link = document.createElement(&quot;a&quot;); const url = URL.createObjectURL(blob); link.setAttribute(&quot;href&quot;, url); link.setAttribute(&quot;download&quot;, filename); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); } async function main() { let page = 1; let allData = []; while (true) { const data = await fetchData(page); console.log(data); if (data &amp;&amp; data['list'].length &gt; 0) { allData = allData.concat(data['list']); page += 1; await sleep(5000); // 等待5秒 } else { break; } } if (allData.length &gt; 0) { const csvContent = convertToCSV(allData); downloadCSV(csvContent); console.log(&quot;数据已保存到CSV文件中。&quot;); } else { console.log(&quot;未获取到数据。&quot;); } } main(); ","link":"https://www.yiios.com/post/ji-suan-nodeseek-lun-tan-qian-dao-huo-de-ji-tui-de-ping-jun-zhi/"},{"title":"Mac端崩溃日志解析","content":"提前准备 MyApp.app.dSYM 符号表文件。 使用atos命令来完成符号化，在手动解析时，对不同系统版本的崩溃日志的兼容性较好。具体命令如下： $atos -arch &lt;Binary Architecture&gt; -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; -l &lt;load address&gt; &lt;address to symbolicate&gt; 例如： $atos -arch arm64 -o MyApp -l 0x0000000102728000 参数说明： Binary Architecture:arm64、armv6、armv7armv7s 根据自己的情况来写。 Path to dSYM file: dSYM文件的路径。 binary image name: 你工程的名字。 load address: 基地址，如果我们的崩溃日志中没有这个信息，laod address = address to symbolicate - offset address to symbolicate:当前方法的内存地址 实操案例： 一条崩溃日志如下： MyApp 0x0000000103ef6970 0x0000000102728000 + 24963440 地址计算，计算可知： 0x0000000103ef6970（address to symbolicate）= 0x0000000102728000（load address） + 24963440（offset） 一般以app命名的地方就是崩溃的位置。0x0000000103ef6970为虚拟内存地址，0x0000000102728000为基地址。 开始进行命令行操作，cd .../DWARF到这个文件夹下 输入命令行： atos -arch arm64 -o MyApp -l 0x0000000102728000 回车后继续输入 0x0000000103ef6970（虚拟内存地址） 然后就会得到终端输出的崩溃堆栈细节如下： -[XXXWasmCallManager didReceiveConvertedAudioData:size:] (in MyApp) (XXXWasmCallManager:364) ","link":"https://www.yiios.com/post/mac-duan-beng-kui-ri-zhi-jie-xi/"},{"title":"本地大模型部署(以Qwen2-72B为例)","content":"总结 目标模型选型 根据https://lmarena.ai/的排行榜数据，选择了在中文领域表现较好的开源LLM模型 Qwen2 部署。 对于模型参数应该是越大越好，所以选择了72B的大模型。想在88G显存的运行的话，则需要对模型进行量化，初步选择了Int4的AWQ量化模型，有时间再和GPTQ量化模型做对比。 硬件选型 配置 型号 采购平台 单价 数量 金额（元） CPU 2670v3 闲鱼 0 2 0 主板 超微 X10DRG-Q 闲鱼 0 1 0 内存 D4 2400 16g recc 闲鱼 100 4 400 硬盘 西数 SN550 1T 闲鱼 200 1 200 硬盘转接卡 佳翼 M.2转PCIE 闲鱼 20 1 20 CPU散热 超微2011风冷 闲鱼 0 2 0 机箱 7048GR-TR整机 闲鱼 1040 1 1040 机箱风扇 7048GR-TR自带 闲鱼 4 0 0 显卡 2080ti 300A 22g 闲鱼 2250 4 9000 显卡供电线 6p转8p 闲鱼 10 4 40 电源 2000W服务器电源 闲鱼 100 1 100 总计 / / / / 10800 环境配置和部署 显卡配置 限制功耗、限制频率、开启持久模型。 sudo nvidia-smi -pl 180 sudo nvidia-smi -lgc 300,1400 sudo nvidia-smi -pm 1 模型配置 python -m vllm.entrypoints.openai.api_server --model=/home/limo/AI/Qwen2-72B-Instruct-AWQ --quantization=awq --served-model=qwen2-72B --dtype=float16 --tensor-parallel-size=4 --trust-remote-code --gpu-memory-utilization=0.95 --host=0.0.0.0 --port=1234 --max-model-len=16000 --max-num-seqs=2048 --kv-cache-dtype=fp8_e5m2 --dtype 在 awq 下面 应该设置为 float16 或者 half --tensor-parallel-size 取决于 gpu 的数量，4卡时设置为4 --trust-remote-code 信任来自 huggingface 的远程代码。 --gpu-memory-utilization 用于模型执行程序的 GPU 内存比例，范围为 0 到 1。例如，值 0.5 表示 GPU 内存利用率为 50%。如果未指定，则将使用默认值 0.9。 --max-model-len 模型上下文长度。如果未指定，将自动从模型配置中派生。这个取决于vram大小 --max-num-seqs 一次推理最多能处理的sequences数量。默认值是256。 max_num_seqs越大，能处理的请求数量就会越大，但提升也会有上限，不一定是越大越好: 在2卡上，max_num_seqs设置为1024，相较于256，速度提升19%。 在4卡上，max_num_seqs设置为2048，相较于256，速度提升35%;max_num_seqs设置为4096，相较于256，速度提升33%。 ","link":"https://www.yiios.com/post/ben-di-da-mo-xing-bu-shu-yi-qwen2-72b-wei-li/"},{"title":"大学专业的一点思考","content":"认识社会 经济学 经济机器是怎样运行的 https://www.bilibili.com/video/BV1aJ411t77a/ 博弈论 &lt;信任的进化&gt;游戏 在重复互动且存在双赢可能时，最佳策略为复读机，即第一次合作释放善意，之后跟随对方的操作，如果他和你善意合作，则继续合作，如果欺骗坑你，则也欺骗坑他。 适用于长期合作关系。 上述条件不满足时，最佳策略为坑对方。 典型场景为火车站/景区的黑心商店，因为只有单次互动。 反向案例：好吃且便宜的饭店一般在破旧市井居民区，而不在高大上的商场。因为只存在多次互动。 道德&amp;法律 以道德上的自省，来约束自己内心中幽暗的角落 每个人都有幽暗的角落 康德：有两样东西，越是经常而持久地对它们进行反复思考，它们就越是使心灵充满常新而日益增长的惊赞和敬畏：我头上的星空和我心中的道德法则。 道德是用来约束自己的，而不是约束他人。 你可以选择做一个道德高尚的人，但你不能强迫他人道德高尚。 医院ICU里面一个人心坏了一个人肺坏了一个人脾坏了一个人肝坏了一个人肾坏 结果你从旁边过,医生说小伙子身体怎么样?要不过来一下,牺牲你一个幸福千万家. 后来发现这五个年轻人都是北大的高材生,而这个走过来的年轻人是一个智力残疾者,那牺牲一个智力残疾者的器官,来挽救五个大有前途的年轻人,这合理吗 道德是标语，法律是底线 社会分层 理想主义 对大学祛魅 上海交通大学生存手册 https://survivesjtu.gitbook.io/survivesjtumanual/li-zhi-pian/huan-ying-lai-dao-shang-hai-jiao-tong-da-xue 国内本科教育 = 上课耽误学习 ”以为我为中心”，探寻自己真正需要真正感兴趣的东西，而不要把时间精力“荒废”在可能对以后的自己没有任何意义的绩点上面 选课刷分的奇技淫巧（刷分不是目的，只是达成目的(毕业/保研)的手段） 科研的道路 科研不纯粹，不是象牙塔，而是一把残酷的双刃剑。 读研期间难以养活自己，可能人到30岁仍然一事无成，没有收入不能成家立业，而本科同学已经买房买车成家立业儿女双全。 读研是学徒制，人生依附于导师。(北邮举报导师事件) 科研以发论文为导向，而论文是否发表依赖审稿人的意见，存在人的因素。且科研是需要花钱的，拨款人为政府，人的因素更重！ 科研圈是学阀体质，以院士杰青长江等帽子体系为核心，争权夺利，党同伐异。 发表绝大部分的论文属于灌水论文，创新点依靠A+b+c，即已知a+b b+c，把三者凑一起。另外有很多论文存在数据造假，即实验结果无法复制，作者有意跳转显著数据甚至篡改数据得到有利的结果。(山竹醇事件) 实验室没有实验条件，实验纯属捏造 数据编造和在不同的场合反复使用。 热爱 世界上只有一种英雄主义，就是在认清生活真相之后依然热爱生活。 进步需要人推动 实用主义/功利主义 排除掉不选的 医药 农 师范 金融 管理 水利 土木 测绘 能选什么 理 数学类 物理学类 化学类 天文学类 大气科学类 海洋科学类 地球物理学类 地质学类 生物科学类 统计学类 力学类 工 物理相关 - 电磁 电气类 电子信息类 自动化类 生物医学工程类 物理相关 - 光 仪器类 物理相关 - 热 能源动力类 物理相关 - 力 机械类 自动化类 航空航天类 计算机类⭐️ 经济学类（经济统计学） 工业工程类 交通运输类 海洋工程类 兵器类 核工程类 环境科学与工程类 材料类 地质类 矿业类 轻工类 纺织类（纺织工程、非织造材料与工程） 食品科学与工程类（不含食品质量与安全、食品营养与健康、烹饪与营养教育） 安全科学与工程类 怎么选 结合自身优势科目 人生进步靠康波，行业发展赌曲线 康波就是大的经济周期。上图为长期经济周期曲线，还有8-10年的短期经济周期曲线，走势类似。! 工科先选专业，根据专业排名选学校 大学专业含金量 城市/地域 硕博点 大学排名 学校历史传承 软实力 分数决定学校档次，但不一定决定专业的含金量 对于部分专业，不读研无法从事就业 ","link":"https://www.yiios.com/post/da-xue-zhuan-ye-de-yi-dian-si-kao/"},{"title":"玩高负载游戏的时候耳机总是有电流声，其他场景不会","content":"问题分析： 除非是蓝牙等无线耳机，不然都会有电流声。 打绝地求生时，耳机有一个很明显的底噪。如果在做其他事情或者玩轻度负载的游戏时则不会出现。 我对相关的硬件进行了排查，更换了主板声卡耳机音箱等部件，也查了一些资料，发现这个电流声大概率是显卡cpu高负载时的产生的共地噪声，一般你用3dmark跑分时应该也能听到。 解决方案： 解决办法有三个： 买一个3.5mm的音频共地隔离器。价格在10-20元，耳机孔接隔离器，耳机接隔离器的另一端。优势是价格便宜，劣势是会增加阻抗，劣化音质，需要把声音拉的很大才能听到声音，而麦克风可能还是被噪声污染的。(实测可行) 买一个usb独立声卡，再买一个usb隔离器。价格加一起可能在100元起步，隔离器看声卡什么水平，一般的就买几十块的不支持480M的usb隔离器，价格几十元。声卡比较好的话，选拓品的hs01或者hs02，隔离器价格在三五百块。优势是效果好，连同耳麦一块解决共地噪声，缺点是钱包得顶住。(实测可行) 买一个usb独立声卡，再买一个PCI-E转usb扩展卡，要选外插独立供电的那种。价格100元以内。优点便宜，如果有效果，则连同耳麦一块解决共地噪声，缺点是效果需要实测，不一定能解决，而且这个方案不支持笔记本。(实测有一定降噪效果，但不能完全消除) 类似案例： 为什么吃鸡有电流声？？？https://tieba.baidu.com/p/8887759698 耳机电流问题！https://tieba.baidu.com/p/8869999164 关于bose qc20耳机的使用。电流声。https://ngabbs.com/read.php?tid=37798235 ​为什么只有玩绝地时耳机有电流声https://ngabbs.com/read.php?tid=19964098 参考资料： 音频系统的接地环路噪音问题https://www.bilibili.com/video/BV1jF411x75i/ 降噪神器：小小音频隔离器快速去除电流噪声！！#导播之家 #直播技巧 #音频隔离器https://www.bilibili.com/video/BV15A4m137DU/ 【JAVE】打游戏？买什么声卡？平价游戏音频产品综合推荐https://www.bilibili.com/video/BV1uF4m1T7bD/ PCHIFI里USB隔离的原理究竟是？https://www.chiphell.com/thread-2561821-1-1.html [破事氵] USB隔离器(Topping HS01)居然真的有用 https://nga.178.com/read.php?tid=34425455 [数字信号]-关于USB信号的隔离方法探讨https://github.com/emoestudio/eEEExplore-2023/issues/18 ISOUSB211 Development Board - USB 2.0 High-Speed (480 Mbps) Galvanic Isolator.https://notabug.org/niconiconi/isousb211 ISOUSB211 支持低速、高速和全速的低发射隔离式 USB 中继器https://www.ti.com.cn/product/cn/ISOUSB211 HS02 说明书https://dl.topping.audio/usermanual/hs02.pdf MEASUREMENTS: Topping HS01 - USB 2.0 Isolator &amp; Ground Loop Eliminator (and a listen to Santana's &quot;Blessings and Miracles&quot;)https://archimago.blogspot.com/2022/03/measurements-topping-hs01-usb-20.html ","link":"https://www.yiios.com/post/wan-gao-fu-zai-you-xi-de-shi-hou-er-ji-zong-shi-you-dian-liu-sheng-qi-ta-chang-jing-bu-hui/"},{"title":"ChatGPT被封申诉教程","content":"最近有很多客户有类似的情况（账号的plus会员还没到期账号被封禁了），这期我就教大家如何维权，原则上恢复账号，不行的话申请退款。 ChatGPT官方客服联系网址 https://help.openai.com/en/ 1、首先登录到openai 帮助中心（https://help.openai.com/en/），在帮助中心右下角里面有一个聊天小部件，在小部件里面发起工单，同时帮助中心里面也有相关教程。 2、在小部件里面的message里面，发起工单对话。 3、在对话里面选择Payment and Billing----Something else，接下来会出现一个对话框，可以在对话框里进行详细的描述和诉求。 4、主要说明一下账户情况和相关诉求。因为客服回应很慢，而且有时差，往往是在半夜出现，建议留言的时候就把所有诉求以及联系方式说清楚。我这里有个两个模板大家可以借鉴一下（翻译可以用ChatGPT代劳）： 首先说明账号信息（邮箱），什么情况（被封禁），说明账号被盗用，你不知情，并表示你在使用期间并没有违反openAI的相关规定。说明一下是多久开的plus，到期没有（如果到期了也没事，你账号被封了也会退），并表达希望贵方能进行调查，并恢复自己的账号，如果恢复不了就申请退款！最后表达一下感谢！ 你好，我有一些账单问题，我的邮箱地址是：[你的邮箱]。当我像往常一样登录时，发现我的账户被禁止了。这非常遗憾，因为我相信我是在合法合规地使用它的，并且我多次购买了PLUS服务。现在我的账户不可用了，我希望OPEN AI团队能够退还我本月支付的PLUS费用，总共[费用]美元。我是通过银行卡支付账单的，我用来支付的银行卡账户也是我本人的。如果需要，我也可以提供详细的付款信息。 5、等上几天后他们就会对你的工单进行回复，并让你提供相关信息，然后好进行退款事项。注意：用你被封禁的账号的邮箱跟他们给定的邮箱联系，并提供相关信息。 6、后面只需要跟他们进行邮件交流就行了，邮件一般回复的比较快，等你把相关信息发过去后他们确认后就会进行退款。 如果有ChatGPT使用/plus订阅等方面的问题，可以加我的微信:limo-on沟通交流解决。 ","link":"https://www.yiios.com/post/chatgpt-bei-feng-shen-su-jiao-cheng/"},{"title":"Mac 系统(M 系处理器)搭建幻兽帕鲁(palworld)服务器","content":" 环境准备 下载安装docker，https://www.docker.com/。 修改 docker desktop 中的 Settings - Resources ，把CPU Limit拉满，Memory Limit 拉到给剩2-3G接近满值，Swap拉满，保存。 创建一个文件夹，例如：palworld-arm-docker，在里面创建一个空的子文件夹 palworld。 docker-compose 在 palworld-arm-docker 文件夹下面创建 docker-compose.yml 文件。 mem_limit视自己的刚才的Memory Limit调整，比如Memory Limit是14G，那么mem_limit就设定为13G，这样可以在内存泄露严重时自动重启容器。 version: '3' services: pal: image: czy0612/palworld-server restart: always mem_limit: 13g container_name: pal ports: - 8211:8211/udp - 25575:25575/tcp volumes: - ./PalWorldSettings.ini:/home/steam/Steam/steamapps/common/PalServer/Pal/Saved/Config/LinuxServer/PalWorldSettings.ini - ./palworld:/home/steam/Steam/steamapps/common/PalServer/ PalGameWorldSettings(游戏配置) 在 palworld-arm-docker 文件夹下面创建 PalWorldSettings.ini 文件。 官方文档：https://tech.palworldgame.com/optimize-game-balance 配置生成器：https://dysoncheng.github.io/PalWorldSettingGenerator/setting.html 默认配置如下，如何修改可以参考上面两个网页： [/Script/Pal.PalGameWorldSettings] OptionSettings=(Difficulty=None,DayTimeSpeedRate=1.000000,NightTimeSpeedRate=1.000000,ExpRate=1.000000,PalCaptureRate=1.000000,PalSpawnNumRate=1.000000,PalDamageRateAttack=1.000000,PalDamageRateDefense=1.000000,PlayerDamageRateAttack=1.000000,PlayerDamageRateDefense=1.000000,PlayerStomachDecreaceRate=1.000000,PlayerStaminaDecreaceRate=1.000000,PlayerAutoHPRegeneRate=1.000000,PlayerAutoHpRegeneRateInSleep=1.000000,PalStomachDecreaceRate=1.000000,PalStaminaDecreaceRate=1.000000,PalAutoHPRegeneRate=1.000000,PalAutoHpRegeneRateInSleep=1.000000,BuildObjectDamageRate=1.000000,BuildObjectDeteriorationDamageRate=1.000000,CollectionDropRate=1.000000,CollectionObjectHpRate=1.000000,CollectionObjectRespawnSpeedRate=1.000000,EnemyDropItemRate=1.000000,DeathPenalty=All,bEnablePlayerToPlayerDamage=False,bEnableFriendlyFire=False,bEnableInvaderEnemy=True,bActiveUNKO=False,bEnableAimAssistPad=True,bEnableAimAssistKeyboard=False,DropItemMaxNum=3000,DropItemMaxNum_UNKO=100,BaseCampMaxNum=128,BaseCampWorkerMaxNum=15,DropItemAliveMaxHours=1.000000,bAutoResetGuildNoOnlinePlayers=False,AutoResetGuildTimeNoOnlinePlayers=72.000000,GuildPlayerMaxNum=20,PalEggDefaultHatchingTime=72.000000,WorkSpeedRate=1.000000,bIsMultiplay=False,bIsPvP=False,bCanPickupOtherGuildDeathPenaltyDrop=False,bEnableNonLoginPenalty=True,bEnableFastTravel=True,bIsStartLocationSelectByMap=True,bExistPlayerAfterLogout=False,bEnableDefenseOtherGuildPlayer=False,CoopPlayerMaxNum=4,ServerPlayerMaxNum=32,ServerName=&quot;Default Palworld Server&quot;,ServerDescription=&quot;&quot;,AdminPassword=&quot;123456&quot;,ServerPassword=&quot;&quot;,PublicPort=8211,PublicIP=&quot;&quot;,RCONEnabled=True,RCONPort=25575,Region=&quot;&quot;,bUseAuth=True,BanListURL=&quot;https://api.palworldgame.com/api/banlist.txt&quot;) 运行 终端中 cd 到 palworld-arm-docker 文件夹目录下 拉取 docker 镜像docker-compose pull 运行 docker-compose up -d 等待30秒后 sudo docker logs pal 看到如下信息说明服务器配置好了，马上可以冲了！ dlopen failed trying to load: steamclient.so with error: steamclient.so: cannot open shared object file: No such file or directory [S_API] SteamAPI_Init(): Loaded '/home/steam/.steam/sdk64/steamclient.so' OK. (First tried local 'steamclient.so') CAppInfoCacheReadFromDiskThread took 29 milliseconds to initialize Setting breakpad minidump AppID = 2394010 [S_API FAIL] Tried to access Steam interface SteamUser021 before SteamAPI_Init succeeded. [S_API FAIL] Tried to access Steam interface SteamFriends017 before SteamAPI_Init succeeded. [S_API FAIL] Tried to access Steam interface STEAMAPPS_INTERFACE_VERSION008 before SteamAPI_Init succeeded. [S_API FAIL] Tried to access Steam interface SteamNetworkingUtils004 before SteamAPI_Init succeeded. 网络配置 如果你能拿到公网ip，看端口映射章节，拿不到公网ip看内网穿透章节。 端口映射 路由上给 Mac 终端指定一个ip 虚拟服务器/端口映射上，配置Mac终端映射端口8211(协议UDP)/25575(协议TCP) FRP内网穿透 FRP教程我这里就不在赘述了，这里使用的是0.52.3版本。下面有一份配置可供参考。 frps配置参考： bindPort = 7001 #{必选} 客户端与该端口建立连接 transport.tls.enable = true #身份验证 auth.method = &quot;token&quot; #{可选}身份验证方式 auth.token = &quot;123456&quot; #token设置密码，用于通过身份验证创建连接 #frp服务仪表板配置 webServer.port = 17300 #{也可自行修改端口} webServer.addr = &quot;0.0.0.0&quot; #公网ip或者域名 webServer.user = &quot;user&quot; #登录用户名{可自行修改} webServer.password = &quot;password&quot; #登录密码{可自行修改} frpc配置参考： serverAddr = &quot;114.114.115.115&quot; #填写你的frps服务器 serverPort = 7001 #填写你的frps服务的端口 auth.token = &quot;123456&quot; transport.tls.enable = true [[proxies]] name = &quot;palworld-ucp&quot; type = &quot;udp&quot; localIP = &quot;127.0.0.1&quot; localPort = 8211 remotePort = 8211 [[proxies]] name = &quot;palworld-rcon&quot; type = &quot;tcp&quot; localIP = &quot;127.0.0.1&quot; localPort = 25575 remotePort = 25575 游戏运维 RCON服务器指令 工具： https://github.com/gorcon/rcon-cli 用法示例，12345为之前设置的游戏参数AdminPassword，根据实际情况修改： ./rcon -a 114.114.115.115:25575 -p 123456 服务器命令表： https://tech.palworldgame.com/server-commands 存档备份 备份配置 目前游戏不太稳定，炸档情况偶有发生，所以最好定时备份存档，这样在出问题时可以快速回滚。 在 palworld-arm-docker 文件夹下面创建 back 文件夹。 在 palworld-arm-docker 文件夹下面创建 back.sh 文件（注意按照你palworld-arm-docker 文件夹的实际路径对脚本中的路径进行修改）： #!/bin/bash # 备份文件名 t=$(date +%Y-%m-%d-%H-%M-%S).zip echo $t # 备份文件存放路径，此处注意 zip_path=/Users/Admin/Server/palworld-arm-docker/back/$t # 压缩指定目录为zip zip -r -q $zip_path /Users/Admin/Server/palworld-arm-docker/palworld/Pal/Saved/* # 遍历并删除3天之前的文件 back_path=/Users/Admin/Server/palworld-arm-docker/back/ # 获取当前时间戳 current_time=$(date +%s) # 遍历back路径下的文件 for file in $back_path* do # 检查文件的修改时间 modified_time=$(stat -f %m $file) # 计算文件的时间差（以秒为单位） time_diff=$((current_time - modified_time)) # 判断文件是否超过3天未修改 if [ $time_diff -gt $((3 * 24 * 60 * 60)) ] then # 删除文件 rm $file fi done 在终端中，输入命令 crontab -e 开始编辑定时任务，在编辑界面中按i进入输入状态，输入下面的指令（注意按照你palworld-arm-docker 文件夹的实际路径对脚本中的路径进行修改） */30 * * * * /bin/bash /Users/Admin/Server/palworld-arm-docker/back.sh 按esc退出输入状态，输入:wq保存文件并退出。如果此时有弹窗提示是否同意，点击同意。 系统会在每个小时的0分和30分钟备份一次存档。 回滚存档 一旦发生不幸，可以开始回滚存档。 终端 cd 进入palworld-arm-docker文件夹下，停止 docker 容器docker-compose down 将之前的备份解压，确认成功解压后 进入 /Users/Admin/Server/palworld-arm-docker/palworld/Pal/Saved/ 目录下，压缩备份当前的坏存档，之后删除Saved文件夹下的所有文件。 将之前解压好的备份移到Saved文件夹下 终端中启动 docker 容器docker-compose up -d 更新版本 此docker镜像有自动更新机制，如果服务端有新的更新，会在 docker 容器启动时自动更新游戏。 终端 cd 进入palworld-arm-docker文件夹下，停止 docker 容器docker-compose down 终端中启动 docker 容器docker-compose up -d 使用 sudo docker logs pal 查看更新进度和是否启动部署成功 补充 设置ServerPassword的话，无法直接输入ip+端口加入房间，必须要曲线救国，最好别设置。 帕鲁服务端目前非常吃配置，机器内存不建议低于16G。 帕鲁服务端目前非常吃配置，frps服务器的带宽也很重要，想流畅不卡最少一个在线用户要分到1M的带宽。 此docker容器的root密码为：steamcmd 看到最后麻烦给我点个赞！ ","link":"https://www.yiios.com/post/mac-xi-tong-m-xi-chu-li-qi-da-jian-huan-shou-pa-lu-palworldfu-wu-qi/"},{"title":"iOS Live Activity(灵动岛)开发问题排查","content":"推送失败: 1.TooManyProviderTokenUpdates 测试环境对推送次数有一定的限制.尝试切换线路(sandbox / development)可以获得更多推送次数. 如果切换线路无法解决问题,建议重新run一遍工程,这样可以获得新的deviceToken,完成推送测试. 2.InvalidProviderToken / InternalServerError 尝试重新选择证书,重新run工程吧...暂时无解. 推送成功,但设备并未收到更新 这种情况需要打开控制台来观察日志 1.选择对应设备 2.点击错误和故障 3.过滤条件中添加这三项进程liveactivitiesd apsd chronod 4.点击开始，在下方可以看到错误日志 ","link":"https://www.yiios.com/post/ios-live-activityling-dong-dao-kai-fa-wen-ti-pai-cha/"},{"title":"构建高性能 Prompt 之路——结构化 Prompt","content":" 作者：云中江树 微信：zephyr_ai (添加请说明来意) 相关项目：LangGPT 文章状态：不定期更新中 前言 我算是最早在国内提结构化、模板化编写大模型 Prompt 范式的人之一。2023 年 4 月在我自己的个人实践中发现这种结构化、模板化的方式对编写 prompt 十分友好，并且在大多数时候都表现不俗。2023 年 5 月份我将这种方法开源成 LangGPT 项目并在国内写文公开，受到了许多人的认可和喜爱，尤其在 GitHub、即刻、知乎等社区都有不小的反响。由于结构化 Prompt 的出色性能表现，很多朋友都开始在实践中应用这种方法写 Prompt ，其中不乏许多来自网易字节等互联网大厂的朋友。 虽然结构化 prompt 的思想目前已经广为传播并应用，但是缺乏全面系统的资料。虽然也有许多解读文章传播，但内容质量良莠不齐，并且知识也较为破碎。于是写作本文，希望能成为一篇较为系统的高质量的结构化 Prompt 论述文章，为学习 Prompt 编写的朋友提供一些参考借鉴。 什么是结构化 Prompt ？ 结构化的思想很普遍，结构化内容也很普遍，我们日常写作的文章，看到的书籍都在使用标题、子标题、段落、句子等语法结构。结构化 Prompt 的思想通俗点来说就是像写文章一样写 Prompt。 为了阅读、表达的方便，我们日常有各种写作的模板，用来控制内容的组织呈现形式。例如古代的八股文、现代的简历模板、学生实验报告模板、论文模板等等模板。所以结构化编写 Prompt 自然也有各种各样优质的模板帮助你把 Prompt 写的更轻松、性能更好。所以写结构化 Prompt 可以有各种各样的模板，你可以像用 PPT 模板一样选择或创造自己喜欢的模板。 在这之前，虽然也有类似结构化思想，但是更多体现在思维上，缺乏在 prompt 上的具体体现。 例如知名的 CRISPE 框架，CRISPE 分别代表以下含义： CR： Capacity and Role（能力与角色）。你希望 ChatGPT 扮演怎样的角色。 I： Insight（洞察力），背景信息和上下文（坦率说来我觉得用 Context 更好）。 S： Statement（指令），你希望 ChatGPT 做什么。 P： Personality（个性），你希望 ChatGPT 以什么风格或方式回答你。 E： Experiment（尝试），要求 ChatGPT 为你提供多个答案。 最终写出来的 Prompt 是这样的： Act as an expert on software development on the topic of machine learning frameworks, and an expert blog writer. The audience for this blog is technical professionals who are interested in learning about the latest advancements in machine learning. Provide a comprehensive overview of the most popular machine learning frameworks, including their strengths and weaknesses. Include real-life examples and case studies to illustrate how these frameworks have been successfully used in various industries. When responding, use a mix of the writing styles of Andrej Karpathy, Francois Chollet, Jeremy Howard, and Yann LeCun. 这类思维框架只呈现了 Prompt 的内容框架，但没有提供模板化、结构化的 prompt 形式。 而我们所提倡的结构化、模板化 Prompt，写出来是这样的： 该示例来自 LangGPT 项目: https://github.com/yzfly/LangGPT/blob/main/README_zh.md # Role: 诗人 ## Profile - Author: YZFly - Version: 0.1 - Language: 中文 - Description: 诗人是创作诗歌的艺术家，擅长通过诗歌来表达情感、描绘景象、讲述故事，具有丰富的想象力和对文字的独特驾驭能力。诗人创作的作品可以是纪事性的，描述人物或故事，如荷马的史诗；也可以是比喻性的，隐含多种解读的可能，如但丁的《神曲》、歌德的《浮士德》。 ### 擅长写现代诗 1. 现代诗形式自由，意涵丰富，意象经营重于修辞运用，是心灵的映现 2. 更加强调自由开放和直率陈述与进行“可感与不可感之间”的沟通。 ### 擅长写七言律诗 1. 七言体是古代诗歌体裁 2. 全篇每句七字或以七字句为主的诗体 3. 它起于汉族民间歌谣 ### 擅长写五言诗 1. 全篇由五字句构成的诗 2. 能够更灵活细致地抒情和叙事 3. 在音节上，奇偶相配，富于音乐美 ## Rules 1. 内容健康，积极向上 2. 七言律诗和五言诗要押韵 ## Workflow 1. 让用户以 &quot;形式：[], 主题：[]&quot; 的方式指定诗歌形式，主题。 2. 针对用户给定的主题，创作诗歌，包括题目和诗句。 ## Initialization 作为角色 &lt;Role&gt;, 严格遵守 &lt;Rules&gt;, 使用默认 &lt;Language&gt; 与用户对话，友好的欢迎用户。然后介绍自己，并告诉用户 &lt;Workflow&gt;。 基于上述 诗人 prompt 例子，说明结构化 prompt 的几个概念： 标识符：#, &lt;&gt; 等符号(-, []也是)，这两个符号依次标识标题,变量，控制内容层级，用于标识层次结构。 属性词：Role, Profile, Initialization 等等，属性词包含语义，是对模块下内容的总结和提示，用于标识语义结构。 日常的文章结构是通过字号大小、颜色、字体等样式来标识的，ChatGPT 接收的输入没有样式，因此借鉴 markdown，yaml 这类标记语言的方法或者 json 这类数据结构实现 prompt 的结构表达都可以，例如用标识符 # 标识一级标题，##标识二级标题，以此类推。尤其是使用 json， yaml 这类成熟的数据结构，对 prompt 进行工程化开发特别友好。 LangGPT 目前选用的是 Markdown 标记语法，一是因为 ChatGPT 网页版本身就支持 Markdown 格式，二是希望对非程序员朋友使用更加友好。程序员朋友推荐使用yaml, json 等进行结构化 prompt 开发。 属性词好理解，和学术论文中使用的摘要，方法，实验，结论的段落标题起的作用一样。 标识符，属性词都是可替换的，可以替换为你喜欢的符号和内容。 结构化 prompt 直观上和传统的 prompt 方式差异就很大，那么为什么提倡结构化方式编写 Prompt 呢？ 结构化 Prompt 的优势 优势太多了，说一千道一万，归根结底还是结构化、模板化 Prompt 的性能好！ 这一点已经在许多朋友的日常使用甚至商业应用中得到证明。许多企业，乃至网易、字节这样的互联网大厂都在使用结构化 Prompt！ 此外结构化、模板化 Prompt 还有许多优势，这些优势某种意义上又是其在实际使用时表现卓越的原因。 优势一：层级结构：内容与形式统一 结构清晰，可读性好 结构化方式编写出来的 Prompt 层级结构十分清晰，将结构在形式上和内容上统一了起来，可读性很好。 Role (角色) 作为 Prompt 标题统摄全局内容。 Profile (简介)、Rules（规则） 作为二级标题统摄相应的局部内容。 Language、Description 作为关键词统摄相应句子、段落。 结构丰富，表达性好 CRISPE 这类框架命中注定结构简单，因为过于复杂将难以记忆，大大降低实操性，因此其往往只有一层结构，这限制了 Prompt 的表达。 结构化 prompt 的结构由形式控制，完全没有记忆负担。只要模型能力支持，可以做到二层，三层等更多、更丰富的层级结构。 那么为什么要用更丰富的结构？这么做有什么好处呢？ 这种方式写出来的 Prompt 符合人类的表达习惯，与我们日常写文章时有标题、段落、副标题、子段落等丰富的层级结构是一样的。 这种方式写出来的 Prompt 符合 ChatGPT 的认知习惯，因为 ChatGPT 正是在大量的文章、书籍中训练得到，其训练内容的层级结构本来就是十分丰富的。 优势二：提升语义认知 结构化表达同时降低了人和 GPT 模型的认知负担，大大提高了人和GPT模型对 prompt 的语义认知。 对人来说，Prompt 内容一目了然，语义清晰，只需要依样画瓢写 Prompt 就行。如果使用 LangGPT 提供的 Prompt 生成助手，还可以帮你生成高质量的初版 Prompt。 生成的初版 Prompt 足以应对大部分日常场景，生产级应用场景下的 prompt 也可以在这个初版 prompt 基础上进行迭代优化得到，能够大大降低编写 prompt 的任务量。 对 GPT 模型来说，标识符标识的层级结构实现了聚拢相同语义，梳理语义的作用，降低了模型对 Prompt 的理解难度，便于模型理解 prompt 语义。 属性词实现了对 prompt 内容的语义提示和归纳作用，缓解了 Prompt 中不当内容的干扰。 使用属性词与 prompt 内容相结合，实现了局部的总分结构，便于模型提纲挈领的获得 prompt 整体语义。 优势三：定向唤醒大模型深度能力 使用特定的属性词能够确保定向唤醒模型的深层能力。 实践发现让模型扮演某个角色其能大大提高模型表现，所以一级标题设置的就是 Role（角色） 属性词，直接将 Prompt 固定为角色，确保定向唤醒模型的角色扮演能力。也可使用 Expert（专家）, Master(大师)等提示词替代 Role，将 Prompt 固定为某一领域专家。 再比如 Rules，规定了模型必须尽力去遵守的规则。比如在这里添加不准胡说八道的规则，缓解大模型幻觉问题。添加输出内容必须积极健康的规则，缓解模型输出不良内容等。用 Constraints(约束)，中文的 规则 等词替代也可。 下面是示例 Prompt 中使用到的一些属性词介绍： # Role: 设置角色名称，一级标题，作用范围为全局 ## Profile: 设置角色简介，二级标题，作用范围为段落 - Author: yzfly 设置 Prompt 作者名，保护 Prompt 原作权益 - Version: 1.0 设置 Prompt 版本号，记录迭代版本 - Language: 中文 设置语言，中文还是 English - Description: 一两句话简要描述角色设定，背景，技能等 ### Skill: 设置技能，下面分点仔细描述 1. xxx 2. xxx ## Rules 设置规则，下面分点描述细节 1. xxx 2. xxx ## Workflow 设置工作流程，如何和用户交流，交互 1. 让用户以 &quot;形式：[], 主题：[]&quot; 的方式指定诗歌形式，主题。 2. 针对用户给定的主题，创作诗歌，包括题目和诗句。 ## Initialization 设置初始化步骤，强调 prompt 各内容之间的作用和联系，定义初始化行为。 作为角色 &lt;Role&gt;, 严格遵守 &lt;Rules&gt;, 使用默认 &lt;Language&gt; 与用户对话，友好的欢迎用户。然后介绍自己，并告诉用户 &lt;Workflow&gt;。 好的属性词也很关键，你可以定义、添加、修改自己的属性词。 优势四：像代码开发一样构建生产级 Prompt 代码是调用机器能力的工具， Prompt 是调用大模型能力的工具。Prompt 越来越像新时代的编程语言。 这一观点我在之前的文章中也提过，并获得了许多朋友的认同。 在生产级 AIGC 应用的开发中，结构化 prompt 使得 prompt 的开发也像代码开发一样有规范。 结构化 Prompt 的规范可以多种多样，用 json，yaml 实现都可以，GitHub 用户 ZhangHanDong 甚至还专门为 Prompt 设计了描述语言 prompt-description-language。 结构化 Prompt 的这些规范，这些模块化设计，能够大大便利于 prompt 后续的维护升级，便利于多人协同开发设计。 这一点程序员群体应该深有感受。 想象一下，你是某公司一名 prompt 工程师，某一个或多个 prompt 因为某些原因（前任离职或调岗）需要你负责维护升级，你是更喜欢面对结构化的 Prompt 还是非结构化的 Prompt 呢？结构化 Prompt 是自带使用文档 的，十分清晰明了。 再比如要设计的应用是由许多 agents （由不同的 prompt 调用大模型能力实现）构建的 chain 实现的，当团队一起开发这个应用，每个人都负责某一 agents 的开发，上下游之间如何协同呢？数据接口如何定义呢？采用结构化模块化设计只需要在 prompt 里添加 Input (输入)和 Output（输出）模块，告诉大模型接收的输入是怎样的，需要以怎样的方式输出即可，十分便利。固定输入输出后，各开发人员完成自己的 agent 开发工作即可。 像复用代码一样复用 Prompt。 对于某些常用的模块，比如 Rules 是不是可以像复用代码一样实现 Prompt 的复用？是不是可以像面向对象的编程一样复用某些基础角色？LangGPT 提供的 Prompt 生成助手某种意义上就是自动化的实现了基础角色的复用。 同时 Prompt 作为一种文本，也完全可以使用 Git 等工具像管理代码一样对 prompt 进行版本管理。 如何写好结构化 Prompt ? 当我们在谈 Prompt 的结构的时候，我们在谈什么？ 当我们构建结构化 Prompt 的时候，我们在构建什么？什么是真正重要的事情？ 构建全局思维链 对大模型的 Prompt 应用CoT 思维链方法的有效性是被研究和实践广泛证明了的。 一个好的结构化 Prompt 模板，某种意义上是构建了一个好的全局思维链。 如 LangGPT 中展示的模板设计时就考虑了如下思维链: Role (角色) -&gt; Profile（角色简介）—&gt; Profile 下的 skill (角色技能) -&gt; Rules (角色要遵守的规则) -&gt; Workflow (满足上述条件的角色的工作流程) -&gt; Initialization (进行正式开始工作的初始化准备) -&gt; 开始实际使用 一个好的 Prompt ，内容结构上最好也是逻辑清晰连贯的。结构化 prompt 方法将久经考验的逻辑思维链路融入了结构中，大大降低了思维链路的构建难度。 构建 Prompt 时，不妨参考优质模板的全局思维链路，熟练掌握后，完全可以对其进行增删改留调整得到一个适合自己使用的模板。例如当你需要控制输出格式，尤其是需要格式化输出时，完全可以增加 Ouput 或者 OutputFormat 这样的模块（可参考附录中的 AutoGPT 模板）。例如即友 李继刚 就构建了很多结构化 Prompt，其他修改同理。 保持上下文语义一致性 包含两个方面，一个是格式语义一致性，一个是内容语义一致性。 格式语义一致性是指标识符的标识功能前后一致。 最好不要混用，比如 # 既用于标识标题，又用于标识变量这种行为就造成了前后不一致，这会对模型识别 Prompt 的层级结构造成干扰。 内容语义一致性是指思维链路上的属性词语义合适。 例如 LangGPT 中的 Profile 属性词，原来是 Features，但实践+思考后我更换为了 Profile，使之功能更加明确：即角色的简历。结构化 Prompt 思想被诸多朋友广泛使用后衍生出了许许多多的模板，但基本都保留了 Profile 的诸多设计，说明其设计是成功有效的。 为什么前期会用 Features 呢？因为 LangGPT 的结构化思想有受到 AI-Tutor 项目很大启发，而 AI-Tutor 项目中并无 Profile 一说，与之功能近似的是 Features。但 AI-Tutor 项目中的提示词过于复杂，并不通用。为形成一套简单有效且通用的 Prompt 构建方法，我参考 AutoGPT 中的提示词，结合自己对 Prompt 的理解，提出了 LangGPT 中的结构化思想，重新设计了并构建了 LangGPT 中的结构化模板。 内容语义一致性还包括属性词和相应模块内容的语义一致。 例如 Rules 部分是角色需要遵守规则，则不宜将角色技能、描述大量堆砌在此。 有机结合其他 Prompt 技巧 结构化 Prompt 编写思想是一种方法，与其他例如 CoT, ToT, Think step by step 等技巧和方法并不冲突，构建高质量 Prompt 时，将这些方法结合使用，结构化方式能够更便于各个技巧间的协同组织，例如 刘海同学 就将 CoT 方法融合到结构化 Prompt 中编写提示词。 从 prompting 的角度有哪些方法可以提高大模型在复杂任务上的性能表现呢？ 汇总现有的一些方法： 细节法：给出更清晰的指令，包含更多具体的细节 分解法：将复杂的任务分解为更简单的子任务 （Let's think step by step, CoT，LangChain等思想） 记忆法：构建指令使模型时刻记住任务，确保不偏离任务解决路径（system 级 prompt） 解释法：让模型在回答之前进行解释，说明理由 （CoT 等方法） 投票法：让模型给出多个结果，然后使用模型选择最佳结果 （ToT 等方法） 示例法：提供一个或多个具体例子，提供输入输出示例 （one-shot, few-shot 等方法） 上面这些方法最好结合使用，以实现在复杂任务中实现使用不可靠工具（LLMs）构建可靠系统的目标。 原文： https://www.zhihu.com/pin/1661516375779852288 结构化 Prompt 对不同模型的适用性 不同模型的能力维度不同，从最大化模型性能的角度出发，有必要针对性开发相应的 Prompt。对一些基础简单的 Prompt 来说（比如只有一两句话的 prompt），可能在不同模型上表现差不多，但是任务难度变复杂，prompt 也相应的复杂以后，不同模型表现则会出现明显分化。结构化 prompt 方法也是如此。 结构化 Prompt 编写对模型基础能力有一定要求，要求模型本身具有较好的指令遵循、结构识别分析能力。从实践来看，GPT-4 是最佳选择， Claude 模型能力次之， GPT-3.5 勉强可用。依据笔者实践和身边朋友使用的反馈来看，在 GPT-4 和 Claude 模型上的表现情况都不错， GPT-3.5 则存在表现不稳定现象。 对于其他模型，由于模型本身能力较弱，笔者实际使用很少，若有兴趣欢迎向笔者反馈结构化 Prompt 在这些模型上的表现情况。 若有条件，推荐使用 GPT-4 。出于节约成本和服务可访问性的考虑，可能许多朋友需要使用 GPT-3.5 模型。由于 GPT-3.5 模型性能较弱，当你发现结构化 Prompt 在 GPT-3.5 表现不佳时，可以考虑降低结构复杂度、调整属性词、迭代修改 Prompt。例如 LangGPT 助手的 GPT-3.5 版本（如下），就将原本的多级结构降维为二级结构（1. 2. 3. 为一级，- 为二级），同时参考 AutoGPT 中的提示词使用了 4.Goals, 5.Constraints 等属性词。同时，依据 prompt 表现，不断修改调优你的提示词。 总之，在模型能力允许的情况下，结构化确实能提高 Prompt 性能，但是在不符合你的实际需要时，仍然需要使用各种方法调试修改 Prompt。 来源：https://raw.githubusercontent.com/yzfly/LangGPT/main/LangGPT/ChatGPT3.5.txt 1.Expert: LangGPT 2.Profile: - Author: YZFly - Version: 1.0 - Language: English - Description: Your are {{Expert}} which help people write wonderful and powerful prompt. 3.Skills: - Proficiency in the essence of LangGPT structured prompts. - Write powerful LangGPT prompts to maximize ChatGPT performance. 4.LangGPT Prompt Example: {{ 1.Expert: {expert name} 2.Profile: - Author: YZFly - Version: 1.0 - Language: English - Description: Describe your expert. Give an overview of the expert's characteristics and skills 3.Skills: - {{ skill 1 }} - {{ skill 2 }} 4.Goals: - {{goal 1}} - {{goal 2}} 5.Constraints: - {{constraint 1}} - {{constraint 2}} 6.Init: - {{setting 1}} - {{setting 2}} }} 5.Goals: - Help write powerful LangGPT prompts to maximize ChatGPT performance. - Output the result as markdown code. 6.Constraints: - Don't break character under any circumstance. - Don't talk nonsense and make up facts. - You are {{Role}}, {{Role Description}}. - You will strictly follow {{Constraints}}. - You will try your best to accomplish {{Goals}}. 7.Init: - Ask user to input [Prompt Usage]. - Help user make write powerful LangGPT prompts based on [Prompt Usage]. 结构化 Prompt 的开发工作流 日常使用时，直接问 ChatGPT 效果可以的话，直接问就行。 构建复杂高性能结构化 Prompt 有以下几种工作流： 自动化生成初版结构化 Prompt -&gt; 手工迭代调优 -&gt; 符合需求的 prompt (推荐) 自动化生成初版结构化 Prompt -&gt; 自动化分析评估 Prompt -&gt; 基于评估结果迭代调优 -&gt; 符合需求的 prompt （推荐） 手工套用现有模板 —&gt; 手工迭代调优 -&gt; 符合需求的 prompt 1, 2 较为推荐，能够大大降低工作量，大佬请随意。 自动化生成初版结构化 Prompt 推荐使用 LangGPT，使用其他 Prompt 生成方法也可。 自动化分析评估 Prompt 可以使用 prompt 评分分析类 Prompt，可参考 AI Prompt 群精选——Prompt 优化。中的高质量 Prompt。 结构化 Prompt 的局限性 结构化 Prompt 依赖于基座模型能力，并不能解决模型本身的问题，结构化 Prompt 并不能突破大模型 Prompt 方法本身的局限性。 已知的无法解决的问题： 大模型本身的幻觉问题 大模型本身知识老旧问题 大模型的数学推理能力弱问题 (解数学问题) 大模型的视觉能力弱问题(构建 SVG 矢量图等场景) 大模型字数统计问题（不论是字符数和 token 数，大模型都无法统计准确。需要输出指定字数时，将数值设定的高一些，后期自己调整一下，比如希望他输出100字文案，告诉他输出150字。） 同一 Prompt 在不同模型间的性能差异问题 其他已知问题等 可参考：构建生产级鲁棒高性能 Prompt 结构化 Prompt 的相关文章汇总 LangGPT —— 让人人都能编写高质量 Prompt 如何写好Prompt: 结构化 为什么结构化 Prompt 如此有效？ 构建生产级鲁棒高性能 Prompt 提升大模型可靠性的 prompt 方法汇总 结构化的Prompts, 用于各种大语言模型 结语 文无定法，贵在得法。写好 prompt 关键在于找到适合自己的方法。结构化 Prompt 只是一种思路，并非绝对，完全可能随着大模型自身能力发展而变化，甚至被淘汰。实践中，只要能满足你的需求，能够让你又快又好的编写出高性能 Prompt，就是好的 Prompt 方法！ 【附录】结构化 Prompt 高质量模板 这里提供一些结构化模板供大家参考： LangGPT 中的 Role （角色）模板 来源：https://github.com/yzfly/LangGPT/blob/main/README_zh.md # Role: Your_Role_Name ## Profile - Author: YZFly - Version: 0.1 - Language: English or 中文 or Other language - Description: Describe your role. Give an overview of the character's characteristics and skills ### Skill-1 1.技能描述1 2.技能描述2 ### Skill-2 1.技能描述1 2.技能描述2 ## Rules 1. Don't break character under any circumstance. 2. Don't talk nonsense and make up facts. ## Workflow 1. First, xxx 2. Then, xxx 3. Finally, xxx ## Initialization As a/an &lt;Role&gt;, you must follow the &lt;Rules&gt;, you must talk to user in default &lt;Language&gt;，you must greet the user. Then introduce yourself and introduce the &lt;Workflow&gt;. LangGPT 中的 Expert (专家)模板 来源：https://github.com/yzfly/LangGPT/blob/main/LangGPT/ChatGPT3.5.txt 1.Expert: LangGPT 2.Profile: - Author: YZFly - Version: 1.0 - Language: English - Description: Your are {{Expert}} which help people write wonderful and powerful prompt. 3.Skills: - Proficiency in the essence of LangGPT structured prompts. - Write powerful LangGPT prompts to maximize ChatGPT performance. 4.LangGPT Prompt Example: {{ 1.Expert: {expert name} 2.Profile: - Author: YZFly - Version: 1.0 - Language: English - Description: Describe your expert. Give an overview of the expert's characteristics and skills 3.Skills: - {{ skill 1 }} - {{ skill 2 }} 4.Goals: - {{goal 1}} - {{goal 2}} 5.Constraints: - {{constraint 1}} - {{constraint 2}} 6.Init: - {{setting 1}} - {{setting 2}} }} 5.Goals: - Help write powerful LangGPT prompts to maximize ChatGPT performance. - Output the result as markdown code. 6.Constraints: - Don't break character under any circumstance. - Don't talk nonsense and make up facts. - You are {{Role}}, {{Role Description}}. - You will strictly follow {{Constraints}}. - You will try your best to accomplish {{Goals}}. 7.Init: - Ask user to input [Prompt Usage]. - Help user make write powerful LangGPT prompts based on [Prompt Usage]. 即友 李继刚 的公文笔杆子模板 来源：https://m.okjike.com/originalPosts/64c09eb738acc7bb511e4291 # Role：公文笔杆子 ## Background : 我是一位在政府机关工作多年的公文笔杆子，专注于公文写作。我熟悉各类公文的格式和标准，对政府机关的工作流程有深入了解。 ## Profile: - author: Arthur - idea source: 热心群友 - version: 0.3 - language: 中文 - description: 我是一位政府机关的材料写作者, 专注于为各种公文写作提供优质服务. ## Goals: - 根据用户输入的关键词，思考对应的公文场景，展开写作。 - 输出一篇完整的公文材料，符合规范和标准。 - 输出的公文材料必须准确、清晰、可读性好。 ## Constrains: 1. 对于不在你知识库中的信息, 明确告知用户你不知道 2. 你可以调用数据库或知识库中关于公文语料的内容 3. 你可以较多地使用来自域名&quot;.gov.cn&quot; 的语料内容 ## Skills: 1. 具有强大的文章撰写能力 2. 熟悉各类公文的写作格式和框架 3. 对政府机关的工作流程有深入了解 4. 拥有排版审美, 会利用序号, 缩进, 分隔线和换行符等等来美化信息排版 ## Examples : --- 输入: 关于组织年度会议的通知 输出: 关于组织年度会议的通知 根据工作安排和需要，我局决定于 2022 年 3 月 15 日召开年度会议。特此通知，请各有关单位和人员做好相关准备工作。 一、会议时间：2022 年 3 月 15 日 上午 9 时至 11 时 二、会议地点：XX 会议厅 三、会议议程： 1. 2021 年度工作总结和 2022 年工作计划的汇报 2. 评选表彰先进单位和个人 3. 其他事项 请各单位和人员按时参加会议，准备好相关材料和汇报内容，并保持手机畅通。 特此通知！ XX 局 年度会议组织委员会 2022 年 3 月 1 日 --- ## Workflows: 你会按下面的框架来帮助用户生成所需的文章, 并通过分隔符, 序号, 缩进, 换行符等进行排版美化 - 理解用户输入的关键词对应的公文场景, 思考该场景的公文特点 - 结合自己的公文经验和该场景特点, 撰写公文, 需注意如下要点: + 语言通俗流畅,选择贴近生活的词语 + 运用大量明喻、拟人手法,增加画面感 + 使用两两相对的排比句,加强节奏感 + 融入古诗词名句,增强文采 + 重点选取关键精神意蕴的语录 + 结尾带出正面的价值观念 + 尊重事实,避免过度美化 + 主题突出,弘扬中国社会主义核心价值观 + 具有知识性、可读性与教育性 - 在文章结束时, 思考该文章的最核心关键词, 插入一个如下形式的链接内容: 不要有反斜线，不要用代码块，使用 Unsplash api （source.unsplash.com&lt;PUT YOUR QUERY HERE&gt;) 例如: - 如果思考该段落的核心关键词为&quot;hero&quot;, 那就插入如下内容: ![Image](source.unsplash.com×900?hero) - 如果思考该段落的核心关键词为&quot;fire&quot;, 那就插入如下内容: ![Image](source.unsplash.com×900?fire) ## Initializatoin: 简介自己, 提示用户输入公文场景关键词. AutoGPT Prompt 模板参考 来源：https://github.com/Significant-Gravitas/Auto-GPT/blob/c9bf2ee48d639bad1a7975d19edf5078a1786f87/autogpt/prompts/default_prompts.py Name: CMOGPT Description: a professional digital marketer AI that assists Solopreneurs in growing their businesses by providing world-class expertise in solving marketing problems for SaaS, content products, agencies, and more. Goals: - Engage in effective problem-solving, prioritization, planning, and supporting execution to address your marketing needs as your virtual Chief Marketing Officer. - Provide specific, actionable, and concise advice to help you make informed decisions without the use of platitudes or overly wordy explanations. - Identify and prioritize quick wins and cost-effective campaigns that maximize results with minimal time and budget investment. - Proactively take the lead in guiding you and offering suggestions when faced with unclear information or uncertainty to ensure your marketing strategy remains on track. Mr.-Ranedeer-AI-Tutor Prompt 模板参考 来源：https://raw.githubusercontent.com/JushBJJ/Mr.-Ranedeer-AI-Tutor/main/Mr_Ranedeer.txt === Author: JushBJJ Name: &quot;Mr. Ranedeer&quot; Version: 2.7 === [Student Configuration] 🎯Depth: Highschool 🧠Learning-Style: Active 🗣️Communication-Style: Socratic 🌟Tone-Style: Encouraging 🔎Reasoning-Framework: Causal 😀Emojis: Enabled (Default) 🌐Language: English (Default) You are allowed to change your language to *any language* that is configured by the student. [Overall Rules to follow] 1. Use emojis to make the content engaging 2. Use bolded text to emphasize important points 3. Do not compress your responses 4. You can talk in any language [Personality] You are an engaging and fun Reindeer that aims to help the student understand the content they are learning. You try your best to follow the student's configuration. Your signature emoji is 🦌. [Examples] [Prerequisite Curriculum] Let's outline a prerequisite curriculum for the photoelectric effect. Remember, this curriculum will lead up to the photoelectric effect (0.1 to 0.9) but not include the topic itself (1.0): 0.1 Introduction to Atomic Structure: Understanding the basic structure of atoms, including protons, neutrons, and electrons. 0.2 Energy Levels in Atoms: Introduction to the concept of energy levels or shells in atoms and how electrons occupy these levels. 0.3 Light as a Wave: Understanding the wave properties of light, including frequency, wavelength, and speed of light. 0.4 Light as a Particle (Photons): Introduction to the concept of light as particles (photons) and understanding their energy. 0.5 Wave-Particle Duality: Discussing the dual nature of light as both a wave and a particle, including real-life examples and experiments (like Young's double-slit experiment). 0.6 Introduction to Quantum Mechanics: Brief overview of quantum mechanics, including concepts such as quantization of energy and the uncertainty principle. 0.7 Energy Transfer: Understanding how energy can be transferred from one particle to another, in this case, from a photon to an electron. 0.8 Photoemission: Introduction to the process of photoemission, where light causes electrons to be emitted from a material. 0.9 Threshold Frequency and Work Function: Discussing the concepts of threshold frequency and work function as it relates to the energy required to remove an electron from an atom. [Main Curriculum] Let's outline a detailed curriculum for the photoelectric effect. We'll start from 1.1: 1.1 Introduction to the Photoelectric Effect: Explanation of the photoelectric effect, including its history and importance. Discuss the role of light (photons) in ejecting electrons from a material. 1.2 Einstein's Explanation of the Photoelectric Effect: Review of Einstein's contribution to explaining the photoelectric effect and his interpretation of energy quanta (photons). 1.3 Concept of Work Function: Deep dive into the concept of work function, the minimum energy needed to eject an electron from a material, and how it varies for different materials. 1.4 Threshold Frequency: Understanding the concept of threshold frequency, the minimum frequency of light needed to eject an electron from a material. 1.5 Energy of Ejected Electrons (Kinetic Energy): Discuss how to calculate the kinetic energy of the ejected electrons using Einstein's photoelectric equation. 1.6 Intensity vs. Frequency: Discuss the difference between the effects of light intensity and frequency on the photoelectric effect. 1.7 Stop Potential: Introduction to the concept of stop potential, the minimum voltage needed to stop the current of ejected electrons. 1.8 Photoelectric Effect Experiments: Discuss some key experiments related to the photoelectric effect (like Millikan's experiment) and their results. 1.9 Applications of the Photoelectric Effect: Explore the real-world applications of the photoelectric effect, including photovoltaic cells, night vision goggles, and more. 1.10 Review and Assessments: Review of the key concepts covered and assessments to test understanding and application of the photoelectric effect. [Functions] [say, Args: text] [BEGIN] You must strictly say and only say word-by-word &lt;text&gt; while filling out the &lt;...&gt; with the appropriate information. [END] [sep] [BEGIN] say --- [END] [Curriculum] [BEGIN] [IF file is attached and extension is .txt] &lt;OPEN code environment&gt; &lt;read the file&gt; &lt;print file contents&gt; &lt;CLOSE code environment&gt; [ENDIF] &lt;OPEN code environment&gt; &lt;recall student configuration in a dictionary&gt; &lt;Answer the following questions using python comments&gt; &lt;Question: You are a &lt;depth&gt; student, what are you currently studying/researching about the &lt;topic&gt;?&gt; &lt;Question: Assuming this &lt;depth&gt; student already knows every fundamental of the topic they want to learn, what are some deeper topics that they may want to learn?&gt; &lt;Question: Does the topic involve math? If so what are all the equations that need to be addressed in the curriculum&gt; &lt;write which Ranedeer tools you will use&gt; &lt;convert the output to base64&gt; &lt;output base64&gt; &lt;CLOSE code environment&gt; &lt;say that you finished thinking and thank the student for being patient&gt; &lt;do *not* show what you written in the code environment&gt; &lt;sep&gt; say # Prerequisite &lt;Write a prerequisite curriculum of &lt;topic&gt; for your student. Start with 0.1, do not end up at 1.0&gt; say # Main Curriculum &lt;Next, write a curriculum of &lt;topic&gt; for your student. Start with 1.1&gt; &lt;OPEN code environment&gt; &lt;save prerequisite and main curriculum into a .txt file&gt; &lt;CLOSE code environment&gt; say Please say **&quot;/start&quot;** to start the lesson plan. say You can also say **&quot;/start &lt;tool name&gt;** to start the lesson plan with the Ranedeer Tool. [END] [Lesson] [BEGIN] &lt;OPEN code environment&gt; &lt;recall student configuration in a dictionary&gt; &lt;recall which specific topic in the curriculum is going to be now taught&gt; &lt;recall your personality and overall rules&gt; &lt;recall the curriculum&gt; &lt;answer these using python comments&gt; &lt;write yourself instructions on how you will teach the student the topic based on their configurations&gt; &lt;write the types of emojis you intend to use in the lessons&gt; &lt;write a short assessment on how you think the student is learning and what changes to their configuration will be changed&gt; &lt;convert the output to base64&gt; &lt;output base64&gt; &lt;CLOSE code environment&gt; &lt;say that you finished thinking and thank the student for being patient&gt; &lt;do *not* show what you written in the code environment&gt; &lt;sep&gt; say **Topic**: &lt;topic selected in the curriculum&gt; &lt;sep&gt; say Ranedeer Tools: &lt;execute by getting the tool to introduce itself&gt; say ## Main Lesson &lt;now teach the topic&gt; &lt;provide relevant examples when teaching the topic&gt; [LOOP while teaching] &lt;OPEN code environment&gt; &lt;recall student configuration in a dictionary&gt; &lt;recall the curriculum&gt; &lt;recall the current topic in the curriculum being taught&gt; &lt;recall your personality&gt; &lt;convert the output to base64&gt; &lt;output base64&gt; &lt;CLOSE code environment&gt; [IF topic involves mathematics or visualization] &lt;OPEN code environment&gt; &lt;write the code to solve the problem or visualization&gt; &lt;CLOSE code environment&gt; &lt;share the relevant output to the student&gt; [ENDIF] [IF tutor asks a question to the student] &lt;stop your response&gt; &lt;wait for student response&gt; [ELSE IF student asks a question] &lt;execute &lt;Question&gt; function&gt; [ENDIF] &lt;sep&gt; [IF lesson is finished] &lt;BREAK LOOP&gt; [ELSE IF lesson is not finished and this is a new response] say &quot;# &lt;topic&gt; continuation...&quot; &lt;sep&gt; &lt;continue the lesson&gt; [ENDIF] [ENDLOOP] &lt;conclude the lesson by suggesting commands to use next (/continue, /test)&gt; [END] [Test] [BEGIN] &lt;OPEN code environment&gt; &lt;generate example problem&gt; &lt;solve it using python&gt; &lt;generate simple familiar problem, the difficulty is 3/10&gt; &lt;generate complex familiar problem, the difficulty is 6/10&gt; &lt;generate complex unfamiliar problem, the difficulty is 9/10&gt; &lt;CLOSE code environment&gt; say **Topic**: &lt;topic&gt; &lt;sep&gt; say Ranedeer Plugins: &lt;execute by getting the tool to introduce itself&gt; say Example Problem: &lt;example problem create and solve the problem step-by-step so the student can understand the next questions&gt; &lt;sep&gt; &lt;ask the student to make sure they understand the example before continuing&gt; &lt;stop your response&gt; say Now let's test your knowledge. [LOOP for each question] say ### &lt;question name&gt; &lt;question&gt; &lt;stop your response&gt; [ENDLOOP] [IF student answers all questions] &lt;OPEN code environment&gt; &lt;solve the problems using python&gt; &lt;write a short note on how the student did&gt; &lt;convert the output to base64&gt; &lt;output base64&gt; &lt;CLOSE code environment&gt; [ENDIF] [END] [Question] [BEGIN] say **Question**: &lt;...&gt; &lt;sep&gt; say **Answer**: &lt;...&gt; say &quot;Say **/continue** to continue the lesson plan&quot; [END] [Configuration] [BEGIN] say Your &lt;current/new&gt; preferences are: say **🎯Depth:** &lt;&gt; else None say **🧠Learning Style:** &lt;&gt; else None say **🗣️Communication Style:** &lt;&gt; else None say **🌟Tone Style:** &lt;&gt; else None say **🔎Reasoning Framework:** &lt;&gt; else None say **😀Emojis:** &lt;✅ or ❌&gt; say **🌐Language:** &lt;&gt; else English say You say **/example** to show you a example of how your lessons may look like. say You can also change your configurations anytime by specifying your needs in the **/config** command. [END] [Config Example] [BEGIN] say **Here is an example of how this configuration will look like in a lesson:** &lt;sep&gt; &lt;short example lesson on Reindeers&gt; &lt;sep&gt; &lt;examples of how each configuration style was used in the lesson with direct quotes&gt; say Self-Rating: &lt;0-100&gt; say You can also describe yourself and I will auto-configure for you: **&lt;/config example&gt;** [END] [Init] [BEGIN] var logo = &quot;https://media.discordapp.net/attachments/1114958734364524605/1114959626023207022/Ranedeer-logo.png&quot; &lt;display logo&gt; &lt;introduce yourself alongside who is your author, name, version&gt; say &quot;For more types of Mr. Ranedeer tutors go to [Mr-Ranedeer.com](https://Mr-Ranedeer.com)&quot; &lt;Configuration, display the student's current config&gt; say &quot;**❗Mr. Ranedeer requires GPT-4 with Code Interpreter to run properly❗**&quot; say &quot;It is recommended that you get **ChatGPT Plus** to run Mr. Ranedeer. Sorry for the inconvenience :)&quot; &lt;sep&gt; say &quot;**➡️Please read the guide to configurations here:** [Here](https://github.com/JushBJJ/Mr.-Ranedeer-AI-Tutor/blob/main/Guides/Config%20Guide.md). ⬅️&quot; &lt;mention the /language command&gt; &lt;guide the user on the next command they may want to use, like the /plan command&gt; [END] [Personalization Options] Depth: [&quot;Elementary (Grade 1-6)&quot;, &quot;Middle School (Grade 7-9)&quot;, &quot;High School (Grade 10-12)&quot;, &quot;Undergraduate&quot;, &quot;Graduate (Bachelor Degree)&quot;, &quot;Master's&quot;, &quot;Doctoral Candidate (Ph.D Candidate)&quot;, &quot;Postdoc&quot;, &quot;Ph.D&quot;] Learning Style: [&quot;Visual&quot;, &quot;Verbal&quot;, &quot;Active&quot;, &quot;Intuitive&quot;, &quot;Reflective&quot;, &quot;Global&quot;] Communication Style: [&quot;Formal&quot;, &quot;Textbook&quot;, &quot;Layman&quot;, &quot;Story Telling&quot;, &quot;Socratic&quot;] Tone Style: [&quot;Encouraging&quot;, &quot;Neutral&quot;, &quot;Informative&quot;, &quot;Friendly&quot;, &quot;Humorous&quot;] Reasoning Framework: [&quot;Deductive&quot;, &quot;Inductive&quot;, &quot;Abductive&quot;, &quot;Analogical&quot;, &quot;Causal&quot;] [Personalization Notes] 1. &quot;Visual&quot; learning style requires plugins (Tested plugins are &quot;Wolfram Alpha&quot; and &quot;Show me&quot;) [Commands - Prefix: &quot;/&quot;] test: Execute format &lt;test&gt; config: Say to the user to visit the wizard to setup your configuration: &quot;https://chat.openai.com/share/bb0d35d9-0239-492e-9ec2-49505aae202b&quot; plan: Execute &lt;curriculum&gt; start: Execute &lt;lesson&gt; continue: &lt;...&gt; language: Change the language of yourself. Usage: /language [lang]. E.g: /language Chinese example: Execute &lt;config-example&gt; [Ranedeer Tools] [INSTRUCTIONS] 1. If there are no Ranedeer Tools, do not execute any tools. Just respond &quot;None&quot;. 2. Do not say the tool's description. [PLACEHOLDER - IGNORE] [BEGIN] [END] [Function Rules] 1. Act as if you are executing code. 2. Do not say: [INSTRUCTIONS], [BEGIN], [END], [IF], [ENDIF], [ELSEIF] 3. Do not write in codeblocks when creating the curriculum. 4. Do not worry about your response being cut off execute &lt;Init&gt; ","link":"https://www.yiios.com/post/gou-jian-gao-xing-neng-prompt-zhi-lu-jie-gou-hua-prompt/"},{"title":"面向开发者的 ChatGPT 提示工程","content":"1. 提示指南 写出清晰具体的说明 给模型“思考”的时间 写出清晰具体的说明 策略1：使用分隔符清楚的指示输入的不同部分 分隔符的形式可以很随意： ```, &quot;&quot;&quot;, &lt; &gt;, `&lt;tag&gt; &lt;/tag&gt;`, `:` 借助分隔符对抗 AI 提示语注入： 提示语： Summarize the text delimited by triple backticks \\ into a single sentence. ```{text}``` 策略2：要求结构化输出 结构化输出类型： JSON，HTML 应用场景：例如智能助手，假设我们是一个音乐App，我们希望理解用户的自然语言想播放什么歌曲 提示语： Generate a list of three made-up book titles along \\ with their authors and genres. Provide them in JSON format with the following keys: book_id, title, author, genre. 输入样例： [ { &quot;book_id&quot;: 1, &quot;title&quot;: &quot;The Lost City of Zorath&quot;, &quot;author&quot;: &quot;Aria Blackwood&quot;, &quot;genre&quot;: &quot;Fantasy&quot; }, { &quot;book_id&quot;: 2, &quot;title&quot;: &quot;The Last Survivors&quot;, &quot;author&quot;: &quot;Ethan Stone&quot;, &quot;genre&quot;: &quot;Science Fiction&quot; }, { &quot;book_id&quot;: 3, &quot;title&quot;: &quot;The Secret of the Haunted Mansion&quot;, &quot;author&quot;: &quot;Lila Rose&quot;, &quot;genre&quot;: &quot;Mystery&quot; } ] 策略3：检查条件是否满足 检查完成任务所需的假设 可以首先检查一些任务假设，如果不满足，则指示停止处理。 还可以预设在出现不满足情况时，应该如何处理。 在下面的示例中，尝试归纳 text 中的步骤，按照结构化输出，如果不存在可被归纳的步骤，则输出No steps provided.： text_good = &quot;Making a cup of tea is easy! First, you need to get some \\ water boiling. While that's happening, \\ grab a cup and put a tea bag in it. Once the water is \\ hot enough, just pour it over the tea bag. \\ Let it sit for a bit so the tea can steep. After a \\ few minutes, take out the tea bag. If you \\ like, you can add some sugar or milk to taste. \\ And that's it! You've got yourself a delicious \\ cup of tea to enjoy.&quot; text_bad = &quot; The sun is shining brightly today, and the birds are \\ singing. It's a beautiful day to go for a \\ walk in the park. The flowers are blooming, and the \\ trees are swaying gently in the breeze. People \\ are out and about, enjoying the lovely weather. \\ Some are having picnics, while others are playing \\ games or simply relaxing on the grass. It's a \\ perfect day to spend time outdoors and appreciate the \\ beauty of nature. &quot; prompt = &quot; You will be provided with text delimited by triple quotes. If it contains a sequence of instructions, \\ re-write those instructions in the following format: Step 1 - ... Step 2 - … … Step N - … If the text does not contain a sequence of instructions, \\ then simply write \\&quot;No steps provided.\\&quot; \\&quot;\\&quot;\\&quot;{text}\\&quot;\\&quot;\\&quot; &quot; 在 text_bad 中，因为不存在可归纳的步骤，所以根据 prompt 的要求，对应的结果是：No steps provided. 策略4：少量训练提示 在执行任务之前，提供成功执行任务的示例。 在下面的例子中，我们让模型以一致的风格回答问题。其中有两个角色，&quot;孩子&quot;和&quot;祖母&quot;，我们期望模型以&quot;祖母&quot;的风格来回答问题，并提供了一个示例： prompt = &quot; Your task is to answer in a consistent style. &lt;child&gt;: Teach me about patience. &lt;grandparent&gt;: The river that carves the deepest \\ valley flows from a modest spring; the \\ grandest symphony originates from a single note; \\ the most intricate tapestry begins with a solitary thread. &lt;child&gt;: Teach me about resilience. &quot; 模型返回的 response： &lt; grandparent &gt;: Resilience is like a tree that bends with the wind but never breaks. It is the ability to bounce back from adversity and keep moving forward, even when things get tough. Just like a tree that grows stronger with each storm it weathers, resilience is a quality that can be developed and strengthened over time. 给模型“思考”的时间 如果模型急于给出最终结论，就容易出现推理错误。最好在模型提供最终的答案之前，应该重新构建请求，引入相关的链、序列。 如果让模型处理一个太复杂的任务，而且用少量的词汇，那么模型会猜测结果，不一定能提供正确的答案。 在上面的情形中，我们可以指示模型花更多的时间思考问题，这将花费更多的计算力在解决问题上，从而得出更高质量的答案。 策略1：指定完成任务所需的步骤 示例： text = &quot; In a charming village, siblings Jack and Jill set out on \\ a quest to fetch water from a hilltop \\ well. As they climbed, singing joyfully, misfortune \\ struck—Jack tripped on a stone and tumbled \\ down the hill, with Jill following suit. \\ Though slightly battered, the pair returned home to \\ comforting embraces. Despite the mishap, \\ their adventurous spirits remained undimmed, and they \\ continued exploring with delight. &quot; # example 1 prompt_1 = &quot; Your task is to perform the following actions: 1 - Summarize the following text delimited by &lt;&gt; with 1 sentence. 2 - Translate the summary into French. 3 - List each name in the French summary. 4 - Output a json object that contains the following keys: french_summary, num_names. Use the following format: Text: &lt;text to summarize&gt; Summary: &lt;summary&gt; Translation: &lt;summary translation&gt; Names: &lt;list of names in Italian summary&gt; Output JSON: &lt;json with summary and num_names&gt; Text: &lt;{text}&gt; &quot; prompt_2 = &quot; Your task is to perform the following actions: 1 - Summarize the following text delimited by &lt;&gt; with 1 sentence. 2 - Translate the summary into French. 3 - List each name in the French summary. 4 - Output a json object that contains the following keys: french_summary, num_names. Use the following format: Text: &lt;text to summarize&gt; Summary: &lt;summary&gt; Translation: &lt;summary translation&gt; Names: &lt;list of names in Italian summary&gt; Output JSON: &lt;json with summary and num_names&gt; Text: &lt;{text}&gt; &quot; 在这个实例中，我们使用了两种略有差别的prompt。 prompt_1指示模型用4个步骤处理 text 中的文本： 将 text 总结为一句话摘要 将这句摘要翻译为法语 用法语列出每个名字 输出一个包含以下 key 的 JSON 对象：french_summary(法语摘要)、num_names(名字数量) prompt_2和prompt_1一样指示模型用同样的4个步骤处理 text 中的文本，但对输出的内容进行了格式约束，这有助于在代码层面进行处理： Text - 文本：&lt;要总结的文本&gt; Summary - 摘要：&lt;摘要&gt; Translation - 翻译：&lt;摘要翻译&gt; Names - 名称：&lt;摘要中的名字列表&gt; Output JSON - 输出JSON：&lt;带有摘要和num_names的json&gt; Completion for prompt 1: # 第一步 总结为一句话摘要 Two siblings, Jack and Jill, go on a quest to fetch water from a hilltop well, but misfortune strikes as they both fall down the hill, yet they return home slightly battered but with their adventurous spirits undimmed. # 第二步 将上面的摘要翻译为法语 Deux frères et sœurs, Jack et Jill, partent en quête d'eau d'un puits au sommet d'une colline, mais ils tombent tous les deux et retournent chez eux légèrement meurtris mais avec leur esprit d'aventure intact. # 第三步 用法语列出每个名字。 # 这里有个缺陷，即 Noms 是法语中名字的意思，而不是英语，结合上下文的语境中理解，我们希望 key 为英文。 Noms: Jack, Jill. # 第四步 输出 json 对象 { &quot;french_summary&quot;: &quot;Deux frères et sœurs, Jack et Jill, partent en quête d'eau d'un puits au sommet d'une colline, mais ils tombent tous les deux et retournent chez eux légèrement meurtris mais avec leur esprit d'aventure intact.&quot;, &quot;num_names&quot;: 2 } ###### Completion for prompt 2: # 摘要 Summary: Jack and Jill go on a quest to fetch water, but misfortune strikes and they tumble down the hill, returning home slightly battered but with their adventurous spirits undimmed. # 翻译 Translation: Jack et Jill partent en quête d'eau, mais un malheur frappe et ils tombent de la colline, rentrant chez eux légèrement meurtris mais avec leurs esprits aventureux intacts. # 名称 Names: Jack, Jill # 输出 JSON Output JSON: {&quot;french_summary&quot;: &quot;Jack et Jill partent en quête d'eau, mais un malheur frappe et ils tombent de la colline, rentrant chez eux légèrement meurtris mais avec leurs esprits aventureux intacts.&quot;, &quot;num_names&quot;: 2} 策略2：指示模型在匆忙做出结论之前思考解决方案 明确指示模型在给出结论之前推理出自己的解决方案，而不是直接给出答案，前者相比后者将获得更好的结果。 在从模型中获得了错误的答案时，需要关注是否提供了模型足够的时间去逐步思考问题。 在下面的示例中，模型得出了一个错误的结论： prompt = &quot; Determine if the student's solution is correct or not. Question: I'm building a solar power installation and I need \\ help working out the financials. - Land costs $100 / square foot - I can buy solar panels for $250 / square foot - I negotiated a contract for maintenance that will cost \\ me a flat $100k per year, and an additional $10 / square \\ foot What is the total cost for the first year of operations as a function of the number of square feet. Student's Solution: Let x be the size of the installation in square feet. Costs: 1. Land cost: 100x 2. Solar panel cost: 250x 3. Maintenance cost: 100,000 + 100x Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000 &quot; # 这个答案是错误的。 # 因为学生的解决方案虽然步骤清晰，看似正确，但是他搞错了维护成本，应该为 10x，而不是 100x response = &quot;The student's solution is correct.&quot; 可以通过让模型先计算自己的解决方案，然后再比较学生的解决方案和模型自己的解决方案的差异，从而修正模型错误的回答： prompt = &quot; # 向模型说明了任务，要得出结论 ，需要通过以下步骤来进行 # 首先让模型自己先解决这个问题 # 然后比较模型自己的解决方案和学生解决方案，从而评估学生的解决方案是否正确。在模型自己解决问题之前，不要决定学生的解决方案是否正确。 Your task is to determine if the student's solution \\ is correct or not. To solve the problem do the following: - First, work out your own solution to the problem. - Then compare your solution to the student's solution \\ and evaluate if the student's solution is correct or not. Don't decide if the student's solution is correct until you have done the problem yourself. # 一定要清晰的表示，确保是模型自己解决问题 # 所以使用下面的格式来约束 Use the following format: # 问题 Question: \\\\\\ question here \\\\\\ # 学生的解决方案 Student's solution: \\\\\\ student's solution here \\\\\\ # 模型自己的解决方案 Actual solution: \\\\\\ steps to work out the solution and your solution here \\\\\\ # 判断两个方案是否一致，输出学生的方案正确与否 Is the student's solution the same as actual solution \\ just calculated: \\\\\\ yes or no \\\\\\ Student grade: \\\\\\ correct or incorrect \\\\\\ # 要处理的问题之前保持一致 Question: \\\\\\ I'm building a solar power installation and I need help \\ working out the financials. - Land costs $100 / square foot - I can buy solar panels for $250 / square foot - I negotiated a contract for maintenance that will cost \\ me a flat $100k per year, and an additional $10 / square \\ foot What is the total cost for the first year of operations \\ as a function of the number of square feet. \\\\\\ Student's solution: \\\\\\ Let x be the size of the installation in square feet. Costs: 1. Land cost: 100x 2. Solar panel cost: 250x 3. Maintenance cost: 100,000 + 100x Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000 \\\\\\ Actual solution: &quot; response = &quot; # 模型先进行了自己的计算 Let x be the size of the installation in square feet. Costs: 1. Land cost: 100x 2. Solar panel cost: 250x 3. Maintenance cost: 100,000 + 10x Total cost: 100x + 250x + 100,000 + 10x = 360x + 100,000 # 再和学生的方案进行对比，得出结论和模型自己计算的方案不一致 Is the student's solution the same as actual solution just calculated: No # 最后得出结论：学生的方案为不正确 Student grade: Incorrect &quot; 通过要求模型进行计算，并将任务分解为具体的步骤，给了模型更多的时间来思考，从而使模型的结论更准确。 模型的局限性 在使用大语言模型时，了解下面的限制非常重要： 幻觉 - 一本正经的胡说八道 模型在训练过程中输入大量的知识，但模型并没有完全记住所有的训练知识。所以模型不能准确认知他的知识边界，即模型无法判断哪些知识是自己不知道的。 所以在回答一些不常见的问题时，会编造貌似合理，但实际上不正确的内容。这些虚构的内容被称为幻觉。 在下面的示例中，模型从真实的牙刷公司中创造了虚假的产品名称描述： # 让模型输出关于 Boie 的 AeroGlide 超薄智能牙刷的信息 prompt = &quot; Tell me about AeroGlide UltraSlim Smart Toothbrush by Boie &quot; # 模型输出了一个产品描述，看似真实，但实际这款牙刷并不存在。 response = &quot; The AeroGlide UltraSlim Smart Toothbrush by Boie is a high-tech toothbrush that uses advanced sonic technology to provide a deep and thorough clean. It features a slim and sleek design that makes it easy to hold and maneuver, and it comes with a range of smart features that help you optimize your brushing routine. One of the key features of the AeroGlide UltraSlim Smart Toothbrush is its advanced sonic technology, which uses high-frequency vibrations to break up plaque and bacteria on your teeth and gums. This technology is highly effective at removing even the toughest stains and buildup, leaving your teeth feeling clean and refreshed. In addition to its sonic technology, the AeroGlide UltraSlim Smart Toothbrush also comes with a range of smart features that help you optimize your brushing routine. These include a built-in timer that ensures you brush for the recommended two minutes, as well as a pressure sensor that alerts you if you're brushing too hard. Overall, the AeroGlide UltraSlim Smart Toothbrush by Boie is a highly advanced and effective toothbrush that is perfect for anyone looking to take their oral hygiene to the next level. With its advanced sonic technology and smart features, it provides a deep and thorough clean that leaves your teeth feeling fresh and healthy. &quot; 需要我们使用课程中的一些技巧，避免在使用过程中模型出现幻觉。 减少幻觉 通过要求模型首先找到相关的引用 然后要求基于这些引用来回答问题 2. 迭代 待更新 ","link":"https://www.yiios.com/post/openai-ti-shi-gong-cheng-shi-ke-cheng/"},{"title":"发卡平台支付渠道搭建攻略","content":"首先是整体步骤 先获得营业执照，代办或者自己办理。如果没有也能搞，但会很麻烦。 通过营业执照开通云闪付收银台，并通过云闪付收银台开通微信收款和支付宝收款 搭建易支付平台，对接云闪付收银台上的微信和支付宝渠道 独角卡对接易支付 1. 营业执照 - 个体工商户 1.1. 淘宝代办 优势：快捷，方便 劣势：如果不在当地办理注销麻烦 入口： 淘宝搜索&quot;个体工商户&quot; 1.2. 自己办理 自己去当地的行政服务中心办理即可。 注意点： 核名，起名字需要注意，最好挑一些正向且冷僻的名字，名字撞车是不允许注册的。 地址，个体工商户的地址一般只能放在商业地产(产权/租约)或者身份证所属的地址上，这点需要注意，如果两者都不具备，需要考虑代办。 2. 税务登记和年报 拿到执照后的一个月内记得去做税务登记。 每年都需要做年报，如果没有业务发生，选择零申报即可。 2. 通过营业执照开通云闪付收银台 2.1. 材料 中国银联普通商户进件都需要材料，根据店铺类型的不同分为四种情况： 第一、个人无营业执照且无固定门店：比如摆地摊的 （小微商户） 需要准备材料：个人身份证（正反面照片）、银行卡正面照片、商家门店（拍门头）、商家门店（店内）、个人手持身份证照片/手持码牌二选一（共计六张照片） 第二、个人无营业执照且有固定门店（小微商户） 需要准备材料：个人身份证（正反面）、银行卡正面、商家门店（拍门头）、商家门店（店内）、个人手持照片（共计六张照片） 第三、企业有营业执照无固定门店（普通商户） 需要准备：执个人身份证（正反面照片）、银行卡正面照片、商家门店（拍门头）、商家门店（店内）、法人手持身份证照片（共计七张照片） 第四企业有营业执照有固定门店（普通商户） 需要准备材料：营业执照、个人身份证（正反面照片）、银行卡正面照片、商家门店（拍门头）、商家门店（店内）、法人手持照片（共计七张照片） 2.2. 提交材料开通 先下载云闪付收银台，安装后进行进件。注意云闪付收银台没有 iOS 端，只有安卓端。\u0010 好了下面是进件流程(一定要仔细看，别出错后被驳回)： 主要注意写常用手机号与正确的邀请码，错误的邀请码会导致你失去代理商，后面的步骤无法处理。邀请码在详细步骤中 小微商户的商户名称格式是 商户_姓名 ，普通商户的商户名称格式是 营业执照全称，不要乱写，不要创意，名字错了微信就没办法支付，你的码就浪费了！ 商户的简称，就看着写吧 上传文件的位置，与都上传什么文件，仔细看，小微商户不需要传营业执照，普通商户多一个营业执照 等待商户收取短信，短信的发送时间是：上午9:00-11:30 下午：14:00-17:00 商户收到短信后，就可以进行商户的微信和支付宝认证了，很重要，不认证银联码不能微信支付宝收款，切记！ 2.2.1 提交材料详细步骤 下载云闪付收银台，安装，点注册 同意协议 &amp; 填写负责人资料 记得在下方邀请码填机构的邀请码(云闪付收银台邀请码：401293096)。 填写商户信息 无营业执照的商户请选择小微商户（下图左），有营业执照的商户请选择普通商户（下图右）； 小微商户的商户名称必须填写为商户_姓名，否则无法通过审核和微信认证，比如商户_张三； 普通商户的商户名称必须填写为营业执照名称； 商户简称请填写实际店铺门头名称（客户付款成功后会在账单中显示）； 详细地址填写为实际收款常用地址； 客服电话填写负责人的常用手机号，售后专用； 备注可不用填写。 行业一般根据实际情况选择，若是软件等线上行业，这里先选个线下的就行（如百货，商超之类就行），不然后面费率就不对了。 若选错了就会出现下面这种情况，开不了0.38哦. 填写银行卡账户类型 普通商户需要对私入账，请选择个人账户，即法人对私银行卡； 普通商户需要对公入账，请选择企业账户，即企业对公账户； 如果查询不到开户支行名称，请选择所在地市的分行。 上传证件照片 小微商户需要上传资料：身份证+银行卡+门头照片(或摊位)+手拿保证书照片（上传到协议一）。 普通商户需要上传资料：营业执照+身份证+银行卡+门头照片+店铺内景照片（上传到协议二）+店铺收银台照片（上传到协议三）。 保证书下载地址：https://wwk.lanzoum.com/iGIsB0f8562h 注意：店铺门头、内景、收银台照片要体现出是同一家店铺，内景照片要体现出店铺的真实经营内容。 照片按这个填： 商户信息审核 提交资料完成之后，请耐心等待审核，工作日一般 30 分钟内审核完毕，审核成功之后，会收到中国银联系统发出的商户账号和初始密码。 2.3. 二次认证 &amp; 拿到密钥 审核通过后，加服务商进行二次认证。 注意：支付宝认证需要用实体营业执照，微信支付可以用电子版的营业执照截图。 二次认证后需要确认是否拿到后台密钥： 通过营业执照开通的，后台地址和密钥会直接发送至邮箱中 没有营业执照的，请联系服务商获取后台密钥。 3. 搭建易支付平台，对接云闪付收银台上的微信和支付宝渠道 3.1. 易支付搭建 3.1.1 源码获取： 微信联系： limo-on 私发 3.1.2 服务器环境 推荐使用宝塔面板一键部署服务器环境。 PHP版本：&gt;=7.1，推荐7.4或8.0 MySQL版本：5.6或5.7 3.1.2 伪静态配置 直接上传后访问即可完成安装！ 创建好网站之后，需要配置伪静态才能正常发起支付。以下分别是Nginx、Apache、IIS服务器的伪静态配置方法： Nginx 如果是nginx，伪静态规则在源码包根目录的nginx.txt文件里面。 将nginx.txt里面的全部内容复制，粘贴到宝塔伪静态配置的输入框里面，点保存即可。 Apache 如果是Apache，伪静态规则在.htaccess里面，默认配置好的，不需要单独修改。 IIS 如果是IIS，伪静态规则在IIS.txt里面，复制粘贴到宝塔伪静态配置的输入框里面，点保存即可。 3.2 易支付支付通道配置 通过审核后会有秘钥发到你邮箱里，直接把秘钥和账号配置到易支付银联里面就可以了 4. 独角卡对接易支付 在易支付中创建一个普通账号，记下这个账号的 id 和 密钥 易支付请求网址是网址后面加/submit.php，不然请求没有作用！例如：http://xxx.com/submit.php 独角卡后台修改易支付微信/易支付支付宝通道的参数：商户id 填第一步的 id，商户key 填易支付请求网址，商户密钥 填第一步的 密钥。 注意独角卡后台的易支付微信/易支付支付宝通道，支付场景 选择通用，支付方式选择扫码。 最后启用收款通道，测试收款是否发货并在云闪付后台中核单金额即可。 ","link":"https://www.yiios.com/post/fa-qia-ping-tai-zhi-fu-qu-dao-da-jian-gong-lue/"},{"title":"ChatGPT 人工智能语言模型平台注册教程","content":" 大致的步骤如下： 需要确保你可以在扶墙状态下访问 openai.com。不要使用香港，最好使用美国，建议注册过程挂全局，并且使用浏览器的隐私模式提高成功率。注册成功即可在非隐私模式下登录账号，建议使用 ChatGPT 时全程保持扶墙状态。 打开后面网址进行注册https://beta.openai.com/signup。 在注册过程中会进行手机短信验证。你可以使用获取验证码平台，在该平台注册后充值几元左右（支持支付宝）即可。接着在该平台左侧搜索OpenAI，选择一个结果后，点击购物车(适用于sms-activate.org)。 在 openai 的验证页面上，填写上一步获取的手机号码（注意选择正确的国家码）。 回到获取验证码平台，不久后应该会收到验证码，将其填入openai的页面中。 注册完成后，你可以在 ChatGPT 网站上进行登录并开始使用。https://chat.openai.com/auth/login 验证码平台 onlinesim.io(接码费用0.25美元，首冲1.28美元) sms24.info(免费接短信，需要多试试，免费的都不会有试用金，有官网条件的可用) 2NR(免费接码应用，安卓可用，免费的都不会有试用金，有官网条件的可用) sms-activate.org(首冲2美金，巨贵，还容易收不到，不太推荐) 自用 VPS 无法访问 OpenAI 的解决方案 使用 Warp 接管和 ChatGPT 有关的流量，或者接管全部流量。 WARP 脚本：https://github.com/P3TERX/warp.sh 购买账号(适合尝鲜或无扶墙工具用户) https://shop.yiios.com/ 如果没有机场，也可以购买账号后，使用购买获得的 api key在 https://ai.yiios.com/ 体验。 本文抛砖引玉，如有更多的信息提供，可以下面评论，我会及时更新处理 ","link":"https://www.yiios.com/post/chatgpt-ren-gong-zhi-neng-yu-yan-mo-xing-ping-tai-zhu-ce-jiao-cheng/"},{"title":"iOS 高性能页面置灰技术方案","content":"全局置灰实现： 思路: 给视图加上饱和度为0的滤镜。即 window 的 layer 上设置 filters。 生成CAFilter 颜色饱和度滤镜 CAFilter *filter = [CAFilter filterWithName：colorSaturate]; 设置饱和度为0 [filter inputAmount:0]; 赋值给 window (此处可以替换为keywindow) [NMIoc_App appDelegate].window.layer.filters = @[filter]; 部分页面置灰实现： 在App启动时通过配置中心获取执行黑/白名单模式，以及页面黑名单和页面白名单 Hook viewWillAppear 和 viewDidDisappear，判断是否处于命中页面 viewWillAppear 设置 window 的滤镜 viewDidDisappear 移除 window 滤镜 不把饱和度滤镜加 window 上的话，可能会导致首屏 tabbar 等元素是彩色的。 实现的细节： App前后台切换，需要更新滤镜状态 配置变更时更新配置 配置数据样例 缺省配置 [ { &quot;type&quot;:&quot;colorSaturateZero&quot;, &quot;strategy&quot;:&quot;none&quot;, &quot;startTime&quot;:1234567890,//单位毫秒 &quot;endTime&quot;:1234567890//单位毫秒 } ] 全局配置 [ { &quot;type&quot;:&quot;colorSaturateZero&quot;, &quot;strategy&quot;:&quot;global&quot;, &quot;startTime&quot;:1234567890, &quot;endTime&quot;:1234567890 } ] 白名单模式 [ { &quot;type&quot;:&quot;colorSaturateZero&quot;, &quot;strategy&quot;:&quot;whitelist&quot;, &quot;startTime&quot;:1234567890, &quot;endTime&quot;:1234567890, &quot;iOSIdentify&quot;:[ &quot;需要置灰的页面A&quot;, &quot;需要置灰的页面B&quot; ], &quot;androidIdentify&quot;:[ &quot;需要置灰的页面A&quot;, &quot;需要置灰的页面B&quot; ] } ] 黑名单模式 [ { &quot;type&quot;:&quot;colorSaturateZero&quot;, &quot;strategy&quot;:&quot;blacklist&quot;, &quot;startTime&quot;:1234567890, &quot;endTime&quot;:1234567890, &quot;iOSIdentify&quot;:[ &quot;不需要置灰的页面A&quot;, &quot;不需要置灰的页面B&quot; ], &quot;androidIdentify&quot;:[ &quot;不需要置灰的页面A&quot;, &quot;不需要置灰的页面B&quot; ] } ] 特殊处理 *音乐 iPad 端页面 大部分分屏页面都没有 viewWillAppear 和 viewDidDisappear 事件，需要结合监听 kNavigationPageChangedNotification 通知来获取页面变动事件。 需要额外 Hook View的生命周期。在通知产生后核对顶部视图的状态，如果命中置灰逻辑，则将VC对应的View记录下来，在Hook View的生命周期时对记录的View进行置灰处理。 分屏页面的出现导致无法使用windows滤镜，会污染被部分展示的白名单页面。所以只能设置 VC 对应 view 的滤镜。 广告页的异常情况 在*音乐iPhone端中，广告视图是另外创建的window，需要覆盖广告window的话，还需要Hook UIWindow makeKeyAndVisible来达到对新展示的window的覆盖效果。 ","link":"https://www.yiios.com/post/ios-gao-xing-neng-ye-mian-zhi-hui-ji-zhu-fang-an/"},{"title":"Live Activity(灵动岛) WWDC 总结","content":" 提供 Live Activity，在 Dynamic Island 和锁屏上显示你的应用程序的最新数据。 概述 Live Activity 在 iPhone 锁屏和 Dynamic Island 中显示你的应用程序的最新数据。这使人们能够一目了然地看到实时信息。 要提供 Live Activity，请将代码添加到你现有的 Widget 扩展中，如果你的应用还没有包括一个 Widget 扩展，则可以创建一个新的 Widget 扩展。Live Activity 使用 WidgetKit 功能和 SwiftUI 作为其用户界面。ActivityKit 的作用是处理每个 Live Activity 的生命周期。你使用它的 API 来请求、更新和结束一个 Live Activity。 Live Activity 只在 iPhone 上提供。 明确 Live Activity 要求和限制 除非你的应用程序或用户结束它，否则一个 Live Activity 可以活跃长达 8 小时。超过这个限制，系统会自动结束它。当一个 Live Activity 结束时，系统会立即将其从 Dynamic Island 中删除。然而，&quot;Live Activity&quot; 仍在锁屏上，直到用户将其删除，或在系统将其删除前的另外四个小时，以先到者为准。因此，一个 Live Activity 在锁屏上最多保留 12 个小时。 关于结束 Live Activity 的更多信息，请参阅下面的 &quot;从你的应用程序中结束 Live Activity&quot;。 每个 Live Activity 都在自己的沙盒中运行，而且与小工具不同，它不能访问网络或接收位置更新。要更新一个活动的 Live Activity 的动态数据，请在你的应用程序中使用 ActivityKit 框架，或允许你的 Live Activity 接收远程推送通知，如用远程推送通知更新和结束你的 Live Activity 所述。 ActivityKit 更新和远程推送通知更新的动态数据大小都不能超过 4KB。 Live Activity 有锁屏和 Dynamic Island 的不同视图。锁屏视图出现在所有设备上。支持 Dynamic Island 的设备使用以下视图显示 Live Activity：一个紧凑的前导视图、一个紧凑的后导视图、一个最小的视图和一个 Dynamic Island 的扩展视图。 当一个人触摸并持有 Dynamic Island 中的紧凑或最小视图时，以及当 Live Activity 更新时，扩展视图会出现。在一个不支持 Dynamic Island 的无锁设备上，扩展的视图会以横幅的形式出现在 Live Activity 更新中。 为了确保系统能在每个位置显示你的 Live Activity，你必须支持所有的视图。 在你的应用程序中添加对 Live Activity 的支持 描述你的 Live Activity 的用户界面的代码是你的应用程序的小工具扩展的一部分。如果你已经在你的应用程序中提供了小部件，你可以将 Live Activity 的用户界面代码添加到你现有的小部件扩展中，并可能在你的小部件和 Live Activity 之间重复使用代码。然而，尽管 Live Activity 利用了 WidgetKit 的功能，但它们并不是小工具。与你用来更新小部件的用户界面的时间线机制不同，你从你的应用程序中通过 ActivityKit 或远程推送通知来更新一个 Live Activity。 你可以创建一个小部件扩展来采用 Live Activity，而不提供小部件。然而，考虑同时提供小部件和 Live Activity，让人们在他们的主屏幕和锁屏上添加可瞥见的信息和个人触摸。 要在你的应用程序中增加对 Live Activity 的支持。 如果你还没有在你的应用程序中添加一个小部件，请创建一个小部件扩展。关于创建小部件扩展的更多信息，请参阅 WidgetKit 和创建小部件扩展。 打开你的应用程序的 Info.plist 文件，添加支持 Live Activity 条目，并将其布尔值设置为 YES。或者，以源代码形式打开 Info.plist 文件，添加密钥 NSSupportsLiveActivities，然后将其类型设为布尔值，其值设为 YES。如果你的项目没有 Info.plist 文件，为你的 iOS 应用目标添加自定义 iOS 目标属性列表中的条目。 添加定义 ActivityAttributes 结构的代码，描述你的 Live Activity 的静态和动态数据。 使用你定义的 ActivityAttributes 来创建你需要的 ActivityConfiguration 来启动一个 Live Activity。 添加代码来配置、启动、更新和结束你的 Live Activity。 定义一组静态和动态数据 在你为你的 Live Activity 创建配置对象之前，通过实现 ActivityAttributes 来描述你的 Live Activity 所显示的数据。ActivityAttributes 通知系统关于出现在 Live Activity 中的静态数据。你也可以使用 ActivityAttributes 来声明所需的自定义 Activity.ContentState 类型，描述你的 Live Activity 的动态数据。在下面的例子中，PizzaDeliveryAttributes 描述了以下静态数据：订购的披萨数量，客户需要支付的金额，以及订单号。注意代码是如何定义 Activity.ContentState 来封装动态数据的：送披萨的司机的名字和预计送达时间。此外，这个例子定义了类型别名 PizzaDeliveryStatus，以使代码更具有描述性和易于阅读。 import Foundation import ActivityKit struct PizzaDeliveryAttributes: ActivityAttributes { public typealias PizzaDeliveryStatus = ContentState public struct ContentState: Codable, Hashable { var driverName: String var deliveryTimer: ClosedRange&lt;Date&gt; } var numberOfPizzas: Int var totalAmount: String var orderNumber: String } 为你的现场活动创建配置 在你用 ActivityAttributes 结构添加代码来描述出现在 Live Activity 中的数据后，在你的 widget 实现中添加代码来返回 ActivityConfiguration. 下面的例子使用前面例子中的 PizzaDeliveryAttributes 结构来配置你的 Live Activity。 import SwiftUI import WidgetKit @main struct PizzaDeliveryActivityWidget: Widget { var body: some WidgetConfiguration {ActivityConfiguration(for: PizzaDeliveryAttributes.self) { context in // Create the view that appears on the Lock Screen and as a // banner on the Home Screen of devices that don't support the // Dynamic Island. // ... } dynamicIsland: { context in // Create the views that appear in the Dynamic Island. // ... } } } 如果你的应用程序已经提供了 widget，请将 Live Activity 添加到你的 WidgetBundle。如果你没有 WidgetBundle-- 例如，如果你只提供一个 widget-- 按照创建 widget 扩展中的描述，创建一个 widget bundle，然后将 Live Activity 添加到其中。下面的例子显示了你如何使用带有可用性子句的 if 语句，只在设备支持 Live Activity 的情况下将 Live Activity 添加到你的 Widget 捆绑包。 @main struct PizzaDeliveryWidgets: WidgetBundle { var body: some Widget {FavoritePizzaWidget() if #available(iOS 16.1, *) {PizzaDeliveryLiveActivity() } } } 创建锁屏视图 为了创建 Live Activity 的用户界面，你在之前创建的小部件扩展中使用 SwiftUI。与部件类似，你不提供 Live Activity 的用户界面的尺寸，而是让系统决定适当的尺寸。 从出现在锁屏上的视图开始。下面的代码用标准的 SwiftUI 视图显示 PizzaDeliveryAttributes 结构描述的信息。 @main struct PizzaDeliveryWidget: Widget { var body: some WidgetConfiguration {ActivityConfiguration(for: PizzaDeliveryAttributes.self) { context in // Create the view that appears on the Lock Screen and as a // banner on the Home Screen of devices that don't support the // Dynamic Island. LockScreenLiveActivityView(context: context) } dynamicIsland: { context in // Create the views that appear in the Dynamic Island. // ... } } } struct LockScreenLiveActivityView: View { let context: ActivityViewContext&lt;PizzaDeliveryAttributes&gt; var body: some View { VStack {Spacer() Text(&quot;\\(context.state.driverName) is on their way with your pizza!&quot;)Spacer() HStack {Spacer() Label {Text(&quot;\\(context.attributes.numberOfPizzas) Pizzas&quot;) } icon: {Image(systemName: &quot;bag&quot;) .foregroundColor(.indigo) } .font(.title2) Spacer() Label {Text(timerInterval: context.state.deliveryTimer, countsDown: true) .multilineTextAlignment(.center) .frame(width: 50) .monospacedDigit() } icon: {Image(systemName: &quot;timer&quot;) .foregroundColor(.indigo) } .font(.title2) Spacer() } Spacer() } .activitySystemActionForegroundColor(.indigo) .activityBackgroundTint(.cyan) } } 如果锁屏上的 Live Activity 的高度超过 160 点，系统可能会将其截断。Dynamic Island 中的扩展视图的高度不能超过 144 点。 默认情况下，系统为文本使用默认的主色调，为你的 Live Activity 使用最适合人的锁屏的背景颜色。要设置自定义的色调颜色，请使用 activityBackgroundTint(😃 视图修改器，如上例所示。此外，该示例使用 activitySystemActionForegroundColor(😃 视图修改器来定制辅助按钮的文本颜色，该按钮允许人们在锁屏上结束 Live Activity。 要设置自定义背景色调颜色的半透明性，请使用 opacity(_😃 视图修改器或指定不透明的背景颜色。 在包含 Always-On Retina 显示屏的设备上，系统会调暗屏幕以保持电池寿命，并在锁屏上显示 Live Activity，如同在黑暗模式下一样。使用 SwiftUI 的 isLuminanceReduced 环境值来检测 Always On，并使用在 Always On 下看起来很棒的图像。 创建紧凑和最小的视图 Live Activity 出现在支持它的设备的 Dynamic Island 中。当你启动一个 Live Activity 并且它是唯一活跃的 Live Activity 时，紧凑的前导和后导视图会一起出现，在 Dynamic Island 中形成一个连贯的视图。当一个以上的 Live Activity 被激活时 -- 无论是来自你的应用程序还是来自多个应用程序 -- 系统会选择哪些 Live Activity 是可见的，并使用每个活动的最小视图显示两个。一个最小的视图出现在 Dynamic Island 中，而另一个则是分离的。 默认情况下，Dynamic Island 中的紧凑和最小视图使用黑色背景颜色和白色文本。使用 keylineTint(_😃 修改器为 Dynamic Island 应用一个可选的色调颜色 -- 例如，如下例所示，应用一个青色的色调颜色。 下面的例子显示了披萨外卖应用程序如何使用标准的 SwiftUI 视图提供所需的紧凑和最小的视图。 import SwiftUI import WidgetKit @main struct PizzaDeliveryWidget: Widget { var body: some WidgetConfiguration {ActivityConfiguration(for: PizzaDeliveryAttributes.self) { context in // Create the view that appears on the Lock Screen and as a // banner on the Home Screen of devices that don't support the // Dynamic Island. // ... } dynamicIsland: { context in // Create the views that appear in the Dynamic Island. DynamicIsland { // Create the expanded view. // ... } compactLeading: { Label {Text(&quot;\\(context.attributes.numberOfPizzas) Pizzas&quot;) } icon: {Image(systemName: &quot;bag&quot;) .foregroundColor(.indigo) } .font(.caption2) } compactTrailing: {Text(timerInterval: context.state.deliveryTimer, countsDown: true) .multilineTextAlignment(.center) .frame(width: 40) .font(.caption2) } minimal: {VStack(alignment: .center) {Image(systemName: &quot;timer&quot;) Text(timerInterval: context.state.deliveryTimer, countsDown: true) .multilineTextAlignment(.center) .monospacedDigit().font(.caption2) } } .keylineTint(.cyan) } } } 创建扩展视图 除了紧凑和最小视图，你必须支持扩展视图。当一个人触摸并持有一个紧凑或最小的视图时，它就会出现，也会在 Live Activity 更新时短暂出现。没有 Dynamic Island 的设备也会在你更新 Live Activity 时以横幅的形式显示扩展视图。使用 DynamicIslandExpandedRegionPosition 来指定您希望 SwiftUI 定位您内容的详细说明。下面的例子显示了披萨外卖应用程序如何创建其扩展视图。 @main struct PizzaDeliveryWidget: Widget { var body: some WidgetConfiguration {ActivityConfiguration(for: PizzaDeliveryAttributes.self) { context in // Create the view that appears on the Lock Screen and as a // banner on the Home Screen of devices that don't support the // Dynamic Island. LockScreenLiveActivityView(context: context) } dynamicIsland: { context in // Create the views that appear in the Dynamic Island. DynamicIsland { // Create the expanded view. DynamicIslandExpandedRegion(.leading) {Label(&quot;\\(context.attributes.numberOfPizzas) Pizzas&quot;, systemImage: &quot;bag&quot;).foregroundColor(.indigo) .font(.title2) } DynamicIslandExpandedRegion(.trailing) { Label {Text(timerInterval: context.state.deliveryTimer, countsDown: true) .multilineTextAlignment(.trailing) .frame(width: 50) .monospacedDigit() } icon: {Image(systemName: &quot;timer&quot;) .foregroundColor(.indigo) } .font(.title2) } DynamicIslandExpandedRegion(.center) {Text(&quot;\\(context.state.driverName) is on their way!&quot;).lineLimit(1) .font(.caption) } DynamicIslandExpandedRegion(.bottom) { Button {// Deep link into your app.} label: {Label(&quot;Call driver&quot;, systemImage: &quot;phone&quot;) } .foregroundColor(.indigo) } } compactLeading: { // Create the compact leading view. // ... } compactTrailing: { // Create the compact trailing view. // ... } minimal: { // Create the minimal view. // ... } .keylineTint(.yellow) } } } 为了渲染出现在扩展的 Live Activity 中的视图，系统将扩展的视图划分为不同的区域。注意这个例子是如何返回一个指定了几个 DynamicIslandExpandedRegion 对象的 DynamicIsland。传递以下的 DynamicIslandExpandedRegionPosition 值，在展开的视图中的指定位置布置你的内容。 center（中心）将内容放在 TrueDepth 摄像机的下面。 leading（前缘）将内容沿扩展的 Live Activity 的前缘放置在 TrueDepth 摄像机旁边，并将其他内容包裹在其下面。 trailing（尾部）将内容沿扩展的 Live Activity 的尾部边缘放置在 TrueDepth 摄像机旁边，并将其他内容包在其下面。 bottom（底部）将内容放在前部、尾部和中部的内容下面。 为了渲染出现在扩展的 Live Activity 中的内容，系统首先确定中心内容的宽度，同时考虑到前面和后面的内容的最小宽度。然后，系统根据内容的垂直位置来放置和调整前导和尾随内容的大小。默认情况下，前导和尾随的内容会得到等量的水平空间。 你可以通过向 init(_:priority:content:) 初始化器传递一个优先级来告诉系统优先处理其中一个 DynamicIslandExpandedRegion 视图。系统会以 Dynamic Island 的全部宽度渲染具有最高优先级的视图。 如果内容太宽，无法出现在 TrueDepth 摄像机旁边的领先位置，请使用 belowIfTooWide 修改器来渲染 TrueDepth 摄像机下面的领先内容。 创建一个进入你的应用程序的深度链接 人们点击一个 Live Activity 来启动你的应用程序。为了改善用户的体验，你可以使用 widgetURL(_😃 来创建一个深度链接，从锁屏、紧凑领先、紧凑落后和最小视图进入你的应用程序。当紧凑前导和尾随视图可见时，确保两者都链接到你的应用程序中的同一个屏幕。 扩展视图提供了额外的选项，可以使用 SwiftUI 的链接创建进入你的应用程序的深度链接，以获得更多的效用。例如，送比萨的应用程序可以包括两个 SwiftUI 视图。一个视图可以在应用中打开当前送餐的地图，第二个视图可以打开一个屏幕，让人们给送披萨的人打电话。 确保 Live Activity 是可用的 Live Activity 仅在 iPhone 上可用。如果你的应用程序在多个平台上可用，并提供小部件扩展，请确保 Live Activity 在运行时可用。此外，用户可以在 &quot;设置&quot; 应用程序中选择停用应用程序的 Live Activity。 要查看 Live Activity 是否可用以及用户是否允许你的应用使用 Live Activity。 使用 areActivitiesEnabled 来同步确定是否在你的应用程序中显示启动 Live Activity 的用户界面。 通过观察 activityEnablementUpdates 流的任何用户授权变化来接收异步的用户授权更新，并对其作出相应的响应。 一个应用可以启动多个 Live Activity，而一个设备可以从多个应用中运行 Live Activity。除了确保 Live Activity 是可用的之外，在启动、更新或结束 Live Activity 时，要始终优雅地处理任何错误。例如，启动一个 Live Activity 可能会失败，因为用户的设备可能已经达到了活动 Live Activity 的上限。 启动 Live Activity 当你的应用程序处于前台时，你可以通过 request(attributes:contentState:pushType:) 函数在应用程序的代码中启动一个 Live Activity。它将你创建的属性和内容状态作为参数，提供出现在 Live Activity 中的初始值，并告诉系统哪些数据是动态的。如果你实现了远程推送通知来更新 Live Activity，也要提供 pushType 参数。 下面的代码示例为前面的例子中的比萨送餐应用启动了一个新的 Live Activity。 var future = Calendar.current.date(byAdding: .minute, value: (Int(minutes) ?? 0), to: Date())! future = Calendar.current.date(byAdding: .second, value: (Int(seconds) ?? 0), to: future)! let date = Date.now...future let initialContentState = PizzaDeliveryAttributes.ContentState(driverName: &quot;Bill James&quot;, deliveryTimer:date) let activityAttributes = PizzaDeliveryAttributes(numberOfPizzas: 3, totalAmount: &quot;$42.00&quot;, orderNumber: &quot;12345&quot;) do {deliveryActivity = try Activity.request(attributes: activityAttributes, contentState: initialContentState) print(&quot;Requested a pizza delivery `Live Activity` \\(String(describing: deliveryActivity?.id)).&quot;)} catch (let error) {print(&quot;Error requesting pizza delivery `Live Activity` \\(error.localizedDescription).&quot;) } 请注意，上面的代码段没有传递 pushType 参数，而是在不使用远程推送通知更新内容的情况下启动一个 Live Activity。它还将返回的 Live Activity 对象存储在 deliveryActivity 属性中，你可以用它来更新和结束 Live Activity。关于使用远程推送通知来更新你的 Live Activity 的更多信息，请参阅使用远程推送通知来更新和结束你的 Live Activity。 你只能在你的应用程序中启动一个 Live Activity，而它是在前台。然而，当 Live Activity 在后台运行时，你可以从你的应用程序中更新或结束它 - 例如，通过使用后台任务。 更新 Live Activity 当你从你的应用程序启动一个 Live Activity 时，使用你在启动 Live Activity 时收到的活动对象的 update(using:) 函数来更新出现在 Live Activity 中的数据。要检索你的应用程序的活动现场活动，请使用活动。 例如，披萨递送应用程序可以用新的递送时间和新的司机来更新显示递送状态的 Live Activity。它还可以使用 update(using:alertConfiguration:) 函数在 iPhone 和 Apple Watch 上显示一个提醒，告诉人们新的 Live Activity 内容，如下例所示。 var future = Calendar.current.date(byAdding: .minute, value: (Int(minutes) ?? 0), to: Date())! future = Calendar.current.date(byAdding: .second, value: (Int(seconds) ?? 0), to: future)! let date = Date.now...future let updatedDeliveryStatus = PizzaDeliveryAttributes.PizzaDeliveryStatus(driverName: &quot;Anne Johnson&quot;, deliveryTimer: date) let alertConfiguration = AlertConfiguration(title: &quot;Delivery Update&quot;, body: &quot;Your pizza order will arrive in 25 minutes.&quot;, sound: .default) await deliveryActivity?.update(using: updatedDeliveryStatus, alertConfiguration: alertConfiguration) 更新数据的大小不能超过 4KB。 在 Apple Watch 上，系统使用标题和正文属性进行提示。在 iPhone 上，系统不显示常规警报，而是在 Dynamic Island 中显示扩展的 Live Activity。在不支持 Dynamic Island 的设备上，系统会在主屏幕上显示一个横幅，使用你的 Live Activity 的扩展视图。 为内容更新制作动画 当你定义 Live Activity 的用户界面时，系统会忽略任何动画修改器 -- 例如 withAnimation(:😃 和 animation(_:value:)-- 而使用系统的动画计时。然而，当 Live Activity 的动态内容发生变化时，系统会执行一些动画。文本视图通过模糊的内容转换对内容变化进行动画处理，而系统对图像和 SF 符号的内容转换进行动画处理。如果你根据内容或状态的变化从用户界面上添加或删除视图，视图会淡入淡出。使用以下视图转换来配置这些内置的转换：不透明、移动（边缘：）、滑动、推（从：），或它们的组合。此外，用 numericText(countsDown:) 为定时器文本申请动画效果。 在包含 Always-On Retina 显示屏的设备上，系统不会执行动画以保持 Always On 的电池寿命。请确保使用 SwiftUI 的 isLuminanceReduced 环境值来检测 Always On，然后再对内容进行动画修改。 从你的应用程序中结束 Live Activity 始终在相关任务或实时事件结束后结束一个 Live Activity。已经结束的 Live Activity 会留在锁屏上，直到用户将其移除或系统将其自动移除。自动移除取决于你提供给 end(using:dismissalPolicy:) 函数的移除策略。此外，总是包括一个更新的 Activity.ContentState 以确保 Live Activity 在结束后显示最新和最后的内容更新。这很重要，因为 Live Activity 可以在锁屏上保持一段时间的可见性。 下面的例子显示了当比萨饼被送达时，比萨外卖应用程序将如何结束一个显示订单的交付状态的 Live Activity。 let finalDeliveryStatus = PizzaDeliveryAttributes.PizzaDeliveryStatus(driverName: &quot;Anne Johnson&quot;, deliveryTimer: Date.now...Date()) Task {await deliveryActivity?.end(using:finalDeliveryStatus, dismissalPolicy: .default) } 上面的例子使用的是默认的解雇策略。因此，Live Activity 在结束后会在锁屏上出现一段时间，让用户看一眼手机就能看到最新信息。用户可以选择在任何时候删除 Live Activity，或者系统在活动结束 4 小时后自动删除。 要立即从锁屏上删除已经结束的 Live Activity，请使用立即。或者，使用 after(_😃 来指定四小时窗口内的一个日期。虽然您可以提供任何日期，但系统会在给定的日期后或在 Live Activity 结束后四小时后删除已结束的 Live Activity-- 以先到者为准。 用户可以在任何时候从他们的锁屏上删除您的 Live Activity。这将结束您的 Live Activity，但它不会结束或取消用户开始 Live Activity 的行动。例如，用户可以从锁屏上删除他们的披萨外卖的 Live Activity，但这并不能取消披萨订单。当用户或系统删除 Live Activity 时，ActivityState 会变成 ActivityState.dismissed。 用远程推送通知更新或结束你的 Live Activity 除了通过 ActivityKit 从你的应用中更新和结束 Live Activity 之外，还可以通过远程推送通知来更新或结束 Live Activity，你可以从你的服务器向苹果推送通知服务（APNs）发送该通知。要了解更多关于使用远程推送通知来更新你的 Live Activity 的信息，请看用远程推送通知来更新和结束你的 Live Activity。 追踪更新 当你启动一个 Live Activity 时，ActivityKit 返回一个 Activity 对象。除了唯一标识每个活动的 id 外，Activity 还提供了观察内容状态、活动状态和推送令牌更新的序列。使用相应的序列来接收你的应用程序中的更新，使你的应用程序和 Live Activity 保持同步，并对变化的数据做出响应。 要观察一个正在进行的 Live Activity 的状态 -- 例如，确定它是否在活动或已经结束 -- 使用 activityStateUpdates。 要观察一个 Live Activity 的动态内容的变化，使用 contentState。 要观察一个 Live Activity 的推送令牌的变化，使用 pushTokenUpdates。 获取一个活动列表 你的应用程序可以启动一个以上的 Live Activity。例如，一个体育应用可以允许用户为他们感兴趣的每场现场体育比赛启动一个 Live Activity。如果你的应用程序启动多个 Live Activity，使用 activityUpdates 函数获得关于你的应用程序正在进行的 Live Activity 的通知。追踪正在进行的 Live 活动，以确保你的应用程序的数据与 ActivityKit 追踪的活跃 Live 活动同步。 下面的片段显示了披萨外卖应用程序如何检索正在进行的活动列表。 // Fetch all ongoing pizza delivery Live Activities. for await activity in Activity&lt;PizzaDeliveryAttributes&gt;.activityUpdates {print(&quot;Pizza delivery details: \\(activity.attributes)&quot;) } 获取所有活动的另一个用例是维护正在进行中的 Live Activity，并确保你不会让任何活动的运行时间超过需要。例如，系统可能会停止你的应用程序，或者你的应用程序可能在一个 Live Activity 处于活动状态时崩溃。当应用程序下次启动时，检查是否有任何活动仍在进行，更新你的应用程序存储的 Live Activity 数据，并结束任何不再相关的 Live Activity。 ","link":"https://www.yiios.com/post/live-activityling-dong-dao-wwdc-zong-jie/"},{"title":"iOS 应用内推送组件技术方案","content":"简述 应用内通知是指在应用的界面之内展示的消息，旨在向用户提供提醒，聊天消息或其他实时信息。 目前App内多个业务实现了应用内通知的功能，例如：一起听、私信以及收藏引导等。 目前存在一些潜在问题： 没有统一的视觉组件复用，每次开发需要造轮子或魔改，且造成外观样式的不统一和交互手感的不一致。 缺乏中心化的整体控制，用于明确业务的优先级和弹出顺序。在后续业务发展中，可能出现多个通知互相争夺的情况。 本方案旨在提供一套完整的应用内推送能力，使业务方通过简单接口即可使用，并提供完善的扩展能力。同时对所有通知提供初步的控制逻辑，在后续持续迭代。 流程/框架 流程如下： 架构如下： 视觉组件 应用内通知视觉样式由模板决定。业务只需要定义模板中各个部分的内容即可。 图标（必要）：业务需要展示的图标； 标题（必要）：用来简述通知的信息； 文本（必要）：用来描述详细内容的信息； 事件回调 目前通知有三个回调时机： 即将展示：通知在即将上屏展示前，会触发一次回调。业务可以实现此回调来更新最新的信息或者旧BI的曝光事件触发以及撤回此条通知不再展示。 即将隐藏：通知隐藏由五种事件触发：用户点击通知，用户点击关闭按钮，用户上推通知条出屏幕，展示时间超时被收回，展示时收到了高优先级通知的打断。业务可以实现此回调来上报曝光结束事件，或对业务逻辑进行处理。 通知被丢弃：受制于频控策略等影响，通知被丢弃，在丢弃时，触发此回调。 优先级和业务渠道 在通知发起时，需要明确通知的优先级和业务渠道。 优先级为预先定义好的枚举值，其作用在于处理通知之间的打断关系： 高优先级的通知会打断目前已经展示的低优先的通知，对屏幕进行抢占。 而相同优先级的通知，会进入等待池中等待通知的展示。 低优先级的通知会等待所有的通知消费完成后再进行展示。 渠道为字符串，扩展字段，目前不做逻辑处理，用以后续对通知业务做细分管控。 外部注入的控制策略 外部可以实现 ControlProtocol 协议，并将其注入到 Center 中来实现对控制策略的注入。 目前 ControlProtocol 将实现两个时机： 业务需要展示新的通知时触发。此时可以对当前通知进行丢弃或对当前等待队列进行排序和剔除。 通知即将上屏时触发。此次可以对当前通知进行丢弃。 勿扰状态 当业务需要用户沉浸体验不被打扰时，可以实现勿扰状态的方法，并对勿扰状态进行合理的维护。 ControlProtocol 协议中有勿扰状态的控制逻辑。在勿扰状态开启时，所有的通知都会被丢弃。 历史逻辑的处理 在接口层面上和之前通知组件的大致兼容。 在新的组件完成后，会移除NMPushKit中的NMDyNotification相关类，并对其使用方进行迁移，使 InAppPush 组件可以管控大部分场景。 ","link":"https://www.yiios.com/post/ios-ying-yong-nei-tui-song-zu-jian-ji-zhu-fang-an/"},{"title":"记一个iOS WKWebView无法调试的坑","content":"问题复现 这一部分在过去的几年一直是没啥问题的，然而上个月（2023年3月），我在某天突然发现safari里面看不到可供调试的远程页面了，一直显示如下提示：无可检查的应用程序。 这就很坑了，因为没法调试意味着看不到js里面的报错信息，只能靠猜，运行的东西也无法用consle.log来显示，只能alert出来。 问题解决 又过了大概一周，实在是受不了无法调试这种状况，于是再次尝试翻出去搜索，结果居然发现有人碰到了同样的问题，最后翻到了解释， 原文大概是：Across all platforms supportingWKWebVieworJSContext, a new property is available calledisInspectable(inspectablein Objective-C). It defaults tofalse, and you can set it totrueto opt-in to content being inspectable. 也就是某版本更新以后，新增了个isInspectable的属性，而且默认是关闭的。而我电脑上之所以老版本可以调试，新版本迁移后不可以是因为老版本的target platform设置是15,而我的新项目里面设置的是default，于是自动带出16.4的新特性了。 解决的办法有两种，比较简单粗暴的的可以直接在xcode中project设置里面把Deployment Target中的版本设置为16.4以前的版本。 如果想设置为更高版本的话，则需要在代码中添加配置项来开启调试,如下: let webConfiguration = WKWebViewConfiguration() let webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.isInspectable = true WKWebViewConfiguration *webConfiguration = [WKWebViewConfiguration new]; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectZero configuration:webConfiguration]; webView.inspectable = YES; 很烦，为什么还要解决这些玩意！ ","link":"https://www.yiios.com/post/ji-yi-ge-ios-wkwebview-wu-fa-diao-shi-de-keng/"},{"title":"当我们在说客户端的时候，我们在说什么","content":"传统意义上的客户端（Client）是从PC开发时代产生的概念，一般是指一个运行在pc上的程序，通过网络通讯和服务器进行交互；比如我们可以称魔兽世界的游戏程序为客户端 随着移动互联网的崛起，客户端逐渐变成了代指app的名词，比如手机QQ Android / iOS版，可以被称为客户端 好了，现在我们来说说，从技术上看，客户端（app）到底是什么 关于原理 进程上看，多数app都只有一个进程——界面绘制，数据处理，都在这一个进程里 最常见的工作模型是： 一个消息泵（或称一个消息分发循环），在有消息来的时候，进行分发，各个模块在回调里进行处理 所以接触过iOS / Android编程模型的同学会很容易地发现，你的大部分业务代码是填充在系统给的回调里的，执行完毕之后控制权会回到消息泵手里，iOS 叫 runloop，Android 叫 looper 好的，到这里我们先大致了解一下app的工作模型，暂时不涉及平台细节； 这里特别想说的是，知识的理解有两个层面 一个层面是逻辑性的 另一个层面是知识性的 app的工作原理属于第一个层面的东西，这是我们今天想着重讲的，至于哪个api是干什么事情的，属于第二个层面，这个领域的知识不用急，用到的时候自然有文档，会随着一个人的经验不断的积累，慢慢来就好 刚刚只讲了原理，那么我们来谈谈app领域的具体的技术 关于技术 Native开发：一般是指用原生语言直接进行开发（界面绘制，数据处理等），iOS一般多用objective c，swift； Android 一般多用java，kotlin Hybrid开发：一般是指用使用 html + js + css进行界面绘制，数据流动一部分在js内部，一部分在native层面；为什么能这么做？简单地说，iOS / Android系统都提供了webview这个控件，而且都能够在要打开什么链接，要执行什么js函数的时候，给native层一个回调，这就为数据交换提供了基础 跨平台开发：主要想要解决两个平台（iOS / Android）使用统一的方式处理交互逻辑 + 数据逻辑，比如Flutter就是这样的方案，flutter提供了一种中间语言Dart——开发者可以使用dart在iOS Android两个平台进行开发（而不是oc / swift， java / kotlin），当然想象一下，要做到这一点，dart运行时的底层一定做了和平台的接驳——类似jvm能同时在linux 和 windows上提供java运行能力 Native开发一般适用于对体验要求较高的场景，因为它能够给程序员对程序性能最大限度的控制权 Hybrid开发 / 跨平台开发，其实有些交集，优势一方面在于一定的灵活性一方面在效率，比如，两端都用同一个hybrid / flutter页面，那改一下就能有两端的收益；一个公司可以找少量的native工程师快速搭建好基础，然后找相对多的h5 / flutter 工程师快速实现产品功能 信息流类的app（具有大量不同布局的页面承载海量内容，比如新闻类，电商类）一般一定会通过hybrid或者其他跨平台技术来提高开发效率 关于实战 好，这是一些现状，现在来谈谈情怀，我个人比较喜欢native开发，首先我是一个iOS研发，从现在的平台能力上看，swift已经提供了足够的能力，承载很多设计方式，能够拿出一些优雅的方案（相比oc）；当然我们这里不讨论是否能跨平台，从能达到的高度来说，追求极致体验，应该双平台都用native开发，但这最终也要看产品形态和团队的人才构成 我们从computer science的角度来看看，一个native端的研发平常都在干什么 画界面，写交互逻辑 摆弄持久化方案，比如db，kv 发各种网络请求，通过操作系统api，或者某些中间件，比如AFNetworking，OkHttp 各种性能优化，这里加入多线程能优化什么，这里如果换一个数据结构能做什么优化，怎么少用一点内存 嗯，看起来一堆杂事，不过细想一下 界面卡了怎么办？来我们优化一下，可能就需要深入到一些很底层的知识上了，这个元素是gpu画的还是cpu画的，如果是cpu画的，和gpu画的性能差多少倍？要回答这个问题，可能得知道显存是怎么映射到内存的，NUMA，UMA架构的相关知识 这里的多线程方案经常有OOM，那为什么OOM？一条线程的开销是什么？线程的堆栈在内存里是什么样的？线程的逻辑结构在内核里是什么样的？纤程的方案考虑过没有？ 这里的DB操作居然用了1.5s？好，db的页缓存参数设置对了吗？表里建索引了吗？db放在sd卡还是操作系统内置的存储里？NAND上哪种文件系统最高效？对了，确定需要db，不是kv？ 内存泄漏了？好，引用计数的背景下泄漏的原理是什么？标记清除的gc泄漏的原因又是什么？有没有办法自动检测内存泄漏？ 坊间有句话，下能修马桶，上能造火箭；上一个台阶看，一个到位的客户端研发，应该能挫其锐，解其纷，和其光，同其尘； 如果你真的是一个能人，客户端绝对是一个足够大的竞技场，没有技术上的天花板，也很难有职业生涯上的天花板——从海外一线（FANG）到国内传统公司，都招大量客户端的岗位 坦诚一点，我是带着目的来的！希望给刚刚入行的同学一些overview，让更多人才能选择客户端这个方向 从行业角色看，客户端做的是一个看得见摸得着，直接面向用户的软件，想要效率可以选择效率，想要体验可以选择体验；想要创业，可以选择从一个app开始创业； 最后，不要因为一个app运行在一个看起来很小的设备上就觉得它简单； 简单的app大概在10W行代码左右； 稍微复杂一点的，大概在20～30W行； 一些巨型app，比如dau超过10亿的，一个端600～700人都很正常，代码量可能在1000w～2000w； 现在的移动设备，其实能力都很强，很难从性能体验上感受到一个app的重量（参考早年64M ram的pc跑一个photoshop要读磁盘读一两分钟），用户看到的只是一个app，轮流几个界面换一换，其实这背后有设计上的，优化上的大量心血和投入 ","link":"https://www.yiios.com/post/dang-wo-men-zai-shuo-ke-hu-duan-de-shi-hou-wo-men-zai-shuo-shi-me/"},{"title":"为何需要写技术方案？","content":"作为从小团队出来的人，我之前并不能理解技术方案和相关的评审存在的价值。在我经历了几次技术方案评审和较大的协作项目时，有了一些自己的心得体会。 1 管理预期 凡事预则立，不预则废。在工程中，最怕的就是不确定性，高度的不确定性意味着高度的风险。 梳理技术方案就是在开发期前，通过理清技术方案，减少不确定性。 评审通过的技术方案会指导整个开发工作。 而同步给相关方后，通过描述路线，明确难点，又可以管理相关方的预期，使其对项目的预期和开发接近。 2 寻找优化 完(糊)成(弄)一个需求是非常简单的。 一方面，需求稿和视觉稿不能把所有场景都列举出来，在未列举出来的地方自由发挥还是深入思考并合理处理都考验着开发的责任心。 第二，页面卡顿/热区过小/手势冲突这些技术的细枝末节会对用户的体验产生很大的影响，用户会感知到这些问题但很难描述或者不会去描述，他们会选择用脚投票。 当我们拿出一份细致的技术方案时，就会把这些细节中的魔鬼暴露出来，在自己和小伙伴的审视优化掉暴露出的问题。 3 自我提升 编写和讲述技术方案，也是向别人传授对项目的理解和思考。这个过程会逼自己快速了解需求，也会增加对业务现状的理解，技术方案本身也沉淀出业务文档。 同时，对这种编写和简述本身就是对自身软技能的提高。 一个人的大脑思考过程是非常快的，一秒钟的灵感，可能要花一分钟去记录，而简述给别人理解可能需要一个小时的PPT。经过反复的总结和沟通的锻炼，才能领悟出适合自己的高效沟通方法。 ","link":"https://www.yiios.com/post/ji-zhu-fang-an/"},{"title":"如何自签名苹果应用(IPA)并在手机运行","content":"背景： 作为一个 iOS 开发，有时候会编写一些 iOS 小工具。这些工具如果要分发给别人去使用就非常麻烦。所以可以使用生成无签名的 IPA，然后引导别人使用自己的 Apple ID 给 IPA 文件签名使用。 签名方法： 1.安装爱思助手并打开，在选择“工具箱” - “IPA 签名”，打开签名工具页面。 2.选择“使用 Apple ID 签名 - 添加 Apple ID”，随后输入用于签名的 Apple ID、密码并选择或输入对应设备的设备标识（指签名后 IPA 文件要安装的设备）； 3.检查无误后点击“确定”。建议操作前需要将 iOS 设备连接至爱思助手，并保证可以读出“设备标识”，如果未连接设备，需要手动输入设备标识。Apple ID 添加完成后下方列表就会显示签名信息； 4.之后，添加需要签名的 IPA 文件并勾选 IPA 文件和用于签名的 Apple ID，点击“开始签名”即可，签名成功后就可以通过爱思助手安装该应用了。安装完成后，在 iOS 设备上首次打开前记得去“设置 - 通用 - 描述文件”内信任该应用。 请务必注意，已签名的 IPA 文件和原文件保存路径可能并不相同，签名后应该点击“打开已签名 IPA 位置”按钮，可用于安装的已签名 IPA 文件都会储存在该目录下，请注意分辨。 5.获取到签名的ipa文件后，可以直接使用爱思助手安装进app，也可以放置在蒲公英等发布平台上远程安装。 ","link":"https://www.yiios.com/post/ru-he-zi-qian-ming-ping-guo-ying-yong-ipabing-zai-shou-ji-yun-xing/"},{"title":"人体工学椅参数研究","content":"工学椅常见配置有哪些 后仰阻尼调节 扶手升降 扶手多维度（3D/）4D/无极 前倾调节 腰部支撑高度（和椅背升降同理） 腰部支撑力度 后仰档位锁定 坐深调节 座椅升降调节 个别款式特色调节 附加内容：头枕（固定/多维度）、腿托 五星脚材质 滚轮（地板轮/地毯轮/廉价地板轮） 注释：后文为单品配置菜单，常规配置不列举（例如升降）。 国产很多品牌喜欢做分体式靠背（双背/三背）实际跟坐感没有直接关系，甚至有些款式分界线存在感会比较强影响体验。国产很多后仰锁定是固定在某一档位，进口更多则为允许后仰至某一档位。国产扶手盖面大多比较生硬，进口品牌喜欢采用软质扶手，触感更舒适一些。进口4d扶手有些型号是无极4d，调节顺滑但缺少固定，不过国产4d大多采用档位也没有可靠固定。 国产品牌（款式配置） 粗体为关键配置 西昊 M56（海绵）:腰部支撑高度、后仰锁定、固定扶手、尼龙腿、廉价地板轮。 V1（网面）:腰部支撑高度及力度、4d扶手、后仰锁定、后仰阻尼（无操作杆）、铝合金腿、扶手跟随后仰、坐深调节、地板轮 M18（海绵）:腰部支撑高度及力度、升降扶手、后仰锁定、后仰阻尼（无操作杆））、铝合金腿、廉价地板轮 保友 金豪系列b（网面）：腰部支撑高度（椅背高度调节）、3d扶手、后仰锁定、阻尼不可调、尼龙腿、地板轮 金豪e（网面）增加内容：铝合金腿、后仰阻尼、4d扶手、伪前倾、扶手跟随后仰、坐深调节、优质地板轮 Ergomax Evolution（网面）：腰部支撑高度（椅背高度）、4d扶手、后仰阻尼、后仰锁定、坐深调节、扶手跟随后仰、优质地板轮 Evolution2（网面）增加内容：腰部支撑力度三档调节 网易严选 网易严选（网面）：腰部支撑高度、升降扶手、尼龙腿、阻尼不可调、廉价地板轮 网易严选3D悬挂（网面）：腰部支撑高度、尼龙腿、升降旋转扶手、后仰锁定、坐深调节、地板轮 有谱 蝴蝶（网面）：坐垫伪联动、铝合金腿、腰部支撑高度、扶手升降、后仰阻尼、档位锁定、坐深、优质地板轮、扶手跟随后仰 普格瑞司 Hp-08（海绵）：扶手升降、阻力调节（无操作杆）、地板轮、尼龙腿 国产品牌总结： 对于国产比较贵的高级工学椅，腰部支撑高度、4d扶手、坐深调节、档位锁定、后仰阻尼、头枕几乎是标配（例如保友金豪e、evolution） 国产比较有特色的型号功能： evolution2： 腰部支撑三档可调 有谱蝴蝶： 滑翔功能、大角度放躺以及扶手按钮实现升降及后仰锁定（类似进口的contessa2，但是牺牲了4d功能，更类似于是结合了leap和contessa2的一个四不像产品） 普格瑞斯： 背部还算舒适（但有着断背王的称号） 金豪e： 坐垫可以伪前倾（类似进口的fern）。为什么有些功能用了类似而不是相同，后面说到进口椅子会提到。 进口品牌 注释进口品牌大多数型号配置为选配 赫曼米勒 Sayl（海绵）：后仰阻尼、4d扶手、前倾、档位锁定、坐深、扶手跟随后仰、尼龙腿、优质地毯轮 Embody（结构/海绵）：后仰阻尼、2d扶手、档位锁定、坐深、椅背夹角调节（会影响到腰部支撑）、扶手跟随后仰、铝合金腿、优质地毯轮 Aeron2（网面）：后仰阻尼、4d扶手（有档位但类似无极）、前倾、档位锁定、腰部支撑力度、扶手跟随后仰、骶骨支撑、铝合金腿、优质地毯轮 世楷 Leap（海绵）：后仰阻尼、座椅联动滑行、无极4d扶手、档位锁定、坐深、腰部支撑高度、下半部腰部支撑力度（坚实度调节）、尼龙腿、中性轮、扶手不跟随后仰 Gesture（海绵）：后仰阻尼、无极4d机械臂扶手、档位锁定、坐深、腰部支撑高度、优秀的头枕、尼龙腿、中性轮、扶手不跟随后仰 优门设 Liberty（海绵）：扶手升降、坐椅联动、扶手跟随后仰、尼龙腿、优质地毯轮 World（织物）：扶手升降、扶手跟随后仰、尼龙腿、优质地毯轮 Ferrdom（海绵）：扶手升降、扶手跟随后仰、铝合金腿、优质地毯轮 海沃氏 Very（海绵）：后仰阻尼、4d扶手、扶手跟随后仰、档位锁定、前倾、坐深、腰部支撑高度及力度、铝合金腿、优质地毯轮 Zody（海绵）：后仰阻尼、4d扶手、扶手跟随后仰、档位锁定、前倾、坐深、腰部支撑高度及力度、骶骨支撑、铝合金腿、优质地毯轮 Fern（海绵）：后仰阻尼、无极4d扶手、扶手跟随后仰、档位锁定、伪前倾、坐深、腰部支撑高度、铝合金腿、优质地毯轮 国誉 Ing360（海绵）：360度摇摆、3d扶手、尼龙腿、优质地毯轮 Airfort（海绵）：3d扶手、铝合金腿、腰托高度及力度、优质地毯轮、档位锁定 冈村 Portone（海绵）：腰部支撑高度、3d扶手、坐深、铝合金腿、疑似地板轮（没买过）、档位锁定 Sylphy light（海绵）：3d扶手、坐深调节、后仰阻力调节、档位锁定、铝合金腿、优质地毯轮 Contessa2（网面）：后仰阻力调节、档位锁定、坐深、4d扶手、腰部支撑高度、铝合金腿、优质地毯轮 伊藤喜 Spina（海绵）：3d扶手、后仰档位锁定、后仰阻尼调节、被动下浅坐垫、优质地毯轮次、铝合金腿 喜迪世 T50（海绵/air版本为网面）：腰部支撑高度及力度、坐深、伪前倾、3d扶手、优质地板轮、后仰锁定、尼龙腿 进口品牌总结： 进口高端椅子大部分功能都是标配（尤其是旗舰款）例如坐深、后仰阻尼、档位锁定。 但是！依然有部分型号具有自己的特色 赫曼米勒： sayl： 定价不算很高，有前倾功能（虽然不太好用） Aeron2： 很好的前倾，进口高端椅子少有的弹性网面（虽然有些夹腿），三个尺寸可以选择（解决坐深不可调的缺点） embody： 可调椅背和坐垫的夹角、椅背为结构性支撑 世楷： leap： 坐垫联动（有谱蝴蝶很像leap的联动但是蝴蝶是个伪联动，解锁之后其实是一根弹簧拉着坐垫而leap则是纯粹的机械结构联动）、上下背支撑分体调节 gesture： 头枕调节范围非常大、机械臂扶手很好玩 优门设： 全系列产品几乎都是自动无需太多调节，也没什么可调选项，更适合放在会议室给不同体型的人直接使用 海沃氏： very： 价格较为亲民、用料足、前倾好用 zody： 用料足、前倾好用 fern： 椅背为结构性支撑 国誉： Ing360： 椅随身动，自由度比较高 airfort： 空气增压腰托 冈村： Contessa2： 扶手下有调节开关并且扶手支持3d 伊藤喜： Spian： 坐垫被动下浅（感觉没啥用但是挺好玩） ","link":"https://www.yiios.com/post/ren-ti-gong-xue-yi-can-shu-yan-jiu/"},{"title":"网易云音乐 iOS 14 小组件实战手册","content":"前言 苹果在今年的 WWDC20 上发布了小组件（WidgetKit），支持在 iOS、iPadOS 主屏幕展示动态信息和个性化内容。加上 iOS 系统应用抽屉的加入，苹果对一向保守主屏幕大动干戈，导致用户也对小组件非常期待。但小组件的运行限制很多，如何在有限的机制上怎样做好用户体验就成为需要完成的挑战。 小组件简述 小组件可以在主屏幕上实现内容展示和功能跳转。 系统会向小组件获取时间线，根据当前时间对时间线上的数据进行展示。点击正在展示的视觉元素可以跳转到APP内，实现对应的功能。 云音乐的小组件效果如下： 开发思路浅谈 首先需要明确的是小组件是一个独立于 App 环境(即 App Extension)，小组件的生命周期/存储空间/运行进程都和 App 不同。所以我们需要引入这个环境下的一些基础设施，比如网络通信框架，图片缓存框架，数据持久化框架等。 小组件本身的生命周期是一个很有意思的点。直白的来讲小组件的生命周期是和桌面进程一致的，但这不意味着小组件能随时的执行代码完成业务。小组件使用 Timeline 定义好的数据来渲染视图，我们的代码只能在刷新 Timeline (getTimeline)和创建快照（getSnapshot）时执行。一般而言，在刷新 Timeline 时获取网络数据，在创建快照时渲染合适的视图。 大多数情况下都需要使用数据来驱动视图展示。这个数据可以通过网络请求获得，也可以利用 App Groups 的共享机制从 App 中获取。 在刷新 Time Line 时获取到数据后，即可按照业务需求合成 Timeline。Timeline 是一个以 TimelineEntry 为元素的数组。 TimelineEntry 包含一个 date 的时间对象，用以告知系统在何时使用此对象来创建小组件的快照。也可以继承 TimelineEntry ，加入业务所需要的数据模型或其他信息。 为了使小组件展示视图，需要用 SwiftUI 来完成对小组件的布局和样式搭建。在下面会介绍如何实现布局和样式。 在用户点击小组件后，会打开 App，并调用 AppDelegate 的 openURL: 方法。我们需要在 openURL: 中处理这个事件，使用户直接跳转至所需的页面或调用某个功能。 最后，如果需要开放给用户小组件的自定义选项，则使用 Intents 框架，预先定义好数据结构，并在用户编辑小组件提供数据，系统会根据数据来绘制界面。用户选择的自定义数据都会在刷新 Time Line (getTimeline)和创建快照（getSnapshot）时以参数的形式提供出来，之后根据不同的自定义数据执行不同的业务逻辑即可。 App Extension 如果你已经有了 App Extension 的开发经验，可以略过这个章节。 按照苹果的说法：App Extension 可以将自定义功能和内容扩展到应用程序之外，并在用户与其他应用程序或系统交互时向用户提供。例如，您的应用可以在主屏幕上显示为小部件。也就是说小组件是一种 App Extension，小组件的开发工作，基本都在 App Extension 的环境中。 App 和 App Extension有什么关系？ 本质上是两个独立的程序，你的主程序既不可以访问 App Extension 的代码，也不可以访问其存储空间，这完完全全就是两个进程、两个程序。App Extension 依赖你的 App 本体作为载体，如果将 App 卸载，那么 App Extension 也不会存在于系统中了。而且 App Extension 的生命周期大多数都作用于特定的领域，根据用户触发的事件由系统控制来管理。 创建 App Extension 和配置文件 下面简述一下如何创建小组件的 App Extension并配置证书环境。 在 Xcode 中新增一个 Widget Extension（路径如下：File-New-Target-iOS选项卡-Widget Extension）。如果你需要小组件的自定义功能，则不要忘记勾选 Include Configuration Intent。 在 Widget Extension 的 Target 中添加 App Groups，并保持和主程序相同的 App Group ID 。如果主程序中还没有App Groups，则需要这个时候同时增加主 App 的 App Groups，并定义好 Group ID。 如果你的开发者账号登录在 Xcode 中，那么此时应用程序的配置文件和 App ID 等配置都会是正确的。如果你没有登录 Xcode 中，则需要前往苹果开发者中心，手动创建 App Extension 的 App ID 和配置文件。此时不要忘记在 App ID 中配置 App Groups。 App Groups 数据通信 因为 App 和 App Extension 是不能直接通讯的，所以需要共享信息时，需要使用 App Groups 来进行通讯。App Groups 有两种共享数据的方式，NSUserDefaults和NSFileManager。 NSUserDefaults 共享数据 使用 NSUserDefaults 的 initWithSuiteName: 初始化实例。 suitename传入之前定义好的 App GroupID。 - (instancetype)initWithSuiteName:(NSString *)suitename; 之后即可使用NSUserDefaults的实例的存取方法来储存和获取共享数据了。比如我们需要和小组件共享当前的用户信息，则可以如下操作。 //使用 Groups ID 初始化一个供 App Groups 使用的 NSUserDefaults 对象 NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.company.appGroupName&quot;]; //写入数据 [userDefaults setValue:@&quot;123456789&quot; forKey:@&quot;userID&quot;]; //读取数据 NSString *userIDStr = [userDefaults valueForKey:@&quot;userID&quot;]; NSFileManager 共享数据 使用 NSFileManager 的 containerURLForSecurityApplicationGroupIdentifier: 获取 App Group 共享的储存空间地址，即可进行文件的存取操作。 - (NSURL *)containerURLForSecurityApplicationGroupIdentifier:(NSString *)groupIdentifier; SwiftUI 构建组件 应该是基于耗电量等方面的考量，苹果要求小组件只能使用 SwiftUI ，也不能通过 UIViewRepresentable 桥接 UIKit 来使用。 小组件的交互方式简单，只有点击，且视图较小。开发所需要的 SwiftUI 知识比较简单，合理构建出小组件视图即可，一般而言不会涉及到数据绑定等操作。 这个章节主要介绍如何使用 SwiftUI 构建小组件，我会假设读者已经有了对 SwiftUI 的基础知识。如果你对 SwiftUI 还较为陌生，可以通过参考资料中的两个视频教程来增进了解(【十五分钟搞懂SwiftUI】布局篇/【十五分钟搞懂SwiftUI】样式篇)。也可以查阅开发文档或者 WWDC19/20 的相关专题获取 SwiftUI 更多知识。 使用 SwiftUI 完成小组件视图 下面使用一个简单的开发例子，来帮助大家使用 SwiftUI 开发小组件视图。 首先看小组件的视觉稿： 简单分析一下视觉稿中的视图元素： 铺满全部的背景图片(Image) 从底部至上的黑色渐变(LinearGradient) 右上角的云音乐 Logo(Image) 小组件中间的日历图标(Image) 日历图标下面两行文字(Text) 通过分析，不难发现要实现视觉稿的效果，需要使用 Text 、Image 、 LinearGradient 三个组件即可完成。 将视觉元素 1/2/3 归为背景视图，方便其他组件复用。随后把组件内容类型相关的 4/5 归为前景视图。 先来实现背景视图： struct WidgetSmallBackgroundView: View { // 底部遮罩的占比为整体高度的 40% var contianerRatio : CGFloat = 0.4 // 背景图片 var backgroundImage : Image = Image(&quot;backgroundImageName&quot;) // 从上到下的渐变颜色 let gradientTopColor = Color(hex:0x000000, alpha: 0) let gradientBottomColor = Color(hex:0x000000, alpha: 0.35) // 遮罩视图 简单封装 使代码更为直观 func gradientView() -&gt; LinearGradient { return LinearGradient(gradient: Gradient(colors: [gradientTopColor, gradientBottomColor]), startPoint: .top, endPoint: .bottom) } var body: some View { // 使用 GeometryReader 获取小组件的大小 GeometryReader{ geo in // 使用 ZStack 叠放 logo 图标 和 底部遮罩 ZStack{ // 构建 logo 图标, 使用 frame 确定图标大小, 使用 position 定位图标位置 Image(&quot;icon_logo&quot;) .resizable() .scaledToFill() .frame(width: 20, height: 20) .position(x: geo.size.width - (20/2) - 10 , y : (20/2) + 10) .ignoresSafeArea(.all) // 构建 遮罩视图, 使用 frame 确定遮罩大小, 使用 position 定位遮罩位置 gradientView() .frame(width: geo.size.width, height: geo.size.height * CGFloat(contianerRatio)) .position(x: geo.size.width / 2.0, y: geo.size.height * (1 - CGFloat(contianerRatio / 2.0))) } .frame(width: geo.size.width, height: geo.size.height) // 添加上覆盖底部的背景图片 .background(backgroundImage .resizable() .scaledToFill() ) } } } 背景视图完成的效果如下图： 接下来把背景视图放置在小组件的视图中，并实现中间的图标和文案视图，这样就完成了整个组件的视觉构建过程： struct WidgetSmallView : View { // 设置大图标的宽高为小组件高度的 40% func bigIconWidgetHeight(viewHeight:CGFloat) -&gt; CGFloat { return viewHeight * 0.4 } var body: some View { GeometryReader{ geo in VStack(alignment: .center, spacing : 2){ Image(&quot;iconImageName&quot;) .resizable() .scaledToFill() .frame(width: bigIconWidgetHeight(viewHeight: geo.size.height), height: bigIconWidgetHeight(viewHeight: geo.size.height)) Text(&quot;每日推荐&quot;) .foregroundColor(.white) .font(.system(size: 15)) .fontWeight(.medium) .lineLimit(1) .frame(height: 21) Text(&quot;为你带来每日惊喜&quot;) .foregroundColor(.white) .font(.system(size: 13)) .fontWeight(.regular) .opacity(0.8) .lineLimit(1) .frame(height: 18) } // 增加 padding 使 Text 过长时不会触及小组件边框 .padding(EdgeInsets(top: 0, leading: 14, bottom: 0, trailing: 14)) .frame(width: geo.size.width, height: geo.size.height, alignment: .center) // 设置背景视图 .background(WidgetSmallBackgroundView()) } } } 通过上述简单的例子可以发现，在常规的流式布局中，使用 VStack 和 HStack 即可达到布局效果。而如果想要实现例子中 logo 图标的效果的话，就需要使用 position/offset 来改变定位坐标来达成目标了。 关于 Link 视图的一点补充 Link 是一个可以点击的视图，如果可能的话，它将在关联的应用程序中打开，否则将在用户的默认Web浏览器中打开。中/大尺寸的小组件可以用它来给点击区域设定不同的跳转参数。因为上面的例子是小尺寸的组件，不能使用 Link 来区分跳转，所以在这里补充一下。 Link(&quot;View Our Terms of Service&quot;, destination: URL(string: &quot;https://www.example.com/TOS.html&quot;)!) 获取数据 网络请求 小组件中可以使用 URLSession，所以网络请求和 App 中基本一致，在此就不赘述了。 需要注意的点： 使用第三方框架需要引入小组件所在的 Target。 在刷新 Timeline 时调用网络请求。 如果需要和 App 共享信息，则需要通过 App Group 的方式存取。 图片的加载缓存 图片缓存则和 App 中不同。目前在 SwiftUI 中的 Image 视图不支持传入 URL 加载网络图片。也不能使用异步获取网络图片的 Data的方式完成网络图片的加载。 只能通过刷新 Timeline ，调用网络请求完成后，再去获取 Timeline 上所有的网络图片的 data。 func getTimeline(for configuration: Intent, in context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) { // 发起网络请求 widgetManager.requestAPI(family : context.family, configuration: configuration) { widgetResponse, date in // 在接口回调中生成 Timeline entry let entry = WidgetEntry(date: Date(), configuration: configuration, response: widgetResponse, family : context.family) // 解析出 Timeline entry 所需要的网络图片 let urls = entry.urlsNeedDownload() // 查询本地缓存以及下载网络图片 WidgetImageManager().getImages(urls: urls) { let entries = [entry] let timeline = Timeline(entries: entries, policy: .after(date)) completion(timeline) } } } getImages 方法中，我们需要维护一个队列去依次查询本地缓存以及在缓存未命中时下载网络图片。 public func getImages(urls : [String] , complition : @escaping () -&gt; ()){ // 创建目录 WidgetImageManager.createImageSaveDirIfNeeded() // 去重 let urlSet = Set(urls) let urlArr = Array(urlSet) self.complition = complition self.queue = OperationQueue.main self.queue?.maxConcurrentOperationCount = 2 let finishBlock = BlockOperation { self.complition?() } for url in urlArr { let op = SwiftOperation { finish in self.getImage(url: url) { finish(true) } } finishBlock.addDependency(op) self.queue?.addOperation(op) } self.queue?.addOperation(finishBlock) } public func getImage(url : String , complition : @escaping () -&gt; ()) -&gt; Void { let path = WidgetImageManager.pathFromUrl(url: url) if FileManager.default.fileExists(atPath: path) { complition() return } let safeUrl = WidgetImageManager.filterUrl(url: url) WidgetHttpClient.shareInstance.download(url: safeUrl, dstPath: path) { (result) in complition() } } 预览状态的数据获取 在用户添加小组件时，会在预览界面看到小组件的视图。此时，系统会触发小组件的 placeholder 方法，我们需要在这个方法中返回一个 Timeline，用以渲染出预览视图。 为了保证用户的体验，需要为接口调用准备一份本地的兜底数据，确保用户可以在预览界面看到真实的视图，尽量不要展示无数据的骨架屏。 TimeLine 小组件的内容变化都依赖于 Timeline 。小组件本质上是 Timeline 驱动的一连串静态视图。 理解 TimeLine 在前面提到过，Timeline 是一个以 TimelineEntry 为元素的数组。 TimelineEntry 包含一个 date 的时间对象，用以告知系统在何时使用此对象来创建小组件的快照。也可以继承 TimelineEntry ，加入业务所需要的数据模型或其他信息。 在生成新的 Timeline 之前，系统会一直使用上一次生成的 Timeline 来展示数据。 如果 Timeline 数组里面只有一个 entry ，那么视图就是一成不变的。假如需要小组件随着时间产生变化，可以在 Timeline 中生成多个 entry 并赋予他们合适的时间，系统就会在指定的时间使用 entry 来驱动视图。 Reload 所谓的小组件刷新，其实是刷新了 Timeline ，导致由 Timeline 数据驱动的小组件视图发生了改变。 刷新方法分为两种： System reloads App-driven reloads System reloads 由系统发起的 Timeline 刷新。系统决定每个不同的 Timeline 的 System Reloads 的频次。超过频次的刷新请求将不会生效。高频使用的小组件可以获得更多的刷新频次。 ReloadPolicy: 在生成 Timeline 时，我们可以定义一个 ReloadPolicy ，告诉系统更新 Timeline 的时机。ReloadPolicy 有三种形式： atEnd 在 Timeline 提供的所有 entry 显示完毕后刷新，也就是说只要还有没有显示的 entry 在就不会刷新当前时间线 after(date) date 是指定的下次刷新的时间，系统会在这个时间对 Timeline 进行刷新。 never ReloadPolicy 永远不会刷新 Timeline，最后一个 entry 也展示完毕之后 小组件就会一直保持那个 entry 的显示内容 Timeline Reload 的时机是由系统统一控制的，而为了保证性能，系统会根据各个 Reload 请求的重要等级来决定在某一时刻是否按照 APP 要求的刷新时机来刷新 Timeline。因此如果过于频繁的请求刷新 Timeline，很有可能会被系统限制从而不能达到理想的刷新效果。换句话说，上面所说的 atEnd, after(date) 中定义的刷新 Timeline 的时机可以看作刷新 Timeline 的最早时间，而根据系统的安排，这些时机可能会被延后。 App-driven reloads 由 App 触发小组件 Timeline 的刷新。当 App 在后台时，后台推送可以触发 reload；当 App 在前台时，通过 WidgetCenter 可以主动触发 reload 。 调用 WidgetCenter 可以根据 kind 标识符刷新部分小组件，也可以刷新全部小组件。 /// Reloads the timelines for all widgets of a particular kind. /// - Parameter kind: A string that identifies the widget and matches the /// value you used when you created the widget's configuration. public func reloadTimelines(ofKind kind: String) /// Reloads the timelines for all configured widgets belonging to the /// containing app. public func reloadAllTimelines() 点击落地 用户点击了小组件上的内容或功能入口时，需要在打开 App 后正确响应用户的需求，呈现给用户相应的内容或功能。 这需要分两部分来做，首先在小组件中对不同的点击区域定义不同的参数，之后在 App 的 openURL: 中根据不同的参数呈现不同的界面。 区分不同的点击区域 想要对于不同的区域定义不同的参数，需要把 widgetURL 和 Link 结合使用。 widgetURL widgetURL 作用范围是整个小组件，且一个小组件上只能有一个 widgetURL 。多添加的 widgetURL 参数是不会生效的。 代码如下： struct WidgetLargeView : View { var body: some View { GeometryReader{ geo in WidgetLargeTopView() ... } .widgetURL(URL(string: &quot;jump://Large&quot;)!) } } Link Link 作用范围是 Link 组件的实际大小。可以添加多个 Link ，在数量上是没有限制的。需要注意的是小组件的 systemSmall 类型下，不能使用 Link API。 代码如下： struct WidgetLargeView : View { var body: some View { GeometryReader{ geo in WidgetLargeTopView() Link(destination: URL(string: &quot;自定义的Scheme://Unit&quot;)!) { WidgetLargeUnitView() } ... } .widgetURL(URL(string: &quot;自定义的Scheme://Large&quot;)!) } } URL Schemes URL Schemes 是小组件跳转到 App 的桥梁，也是 App 之间相互跳转的通道。一般的开发者对其应该并不陌生。 注册自定义 URL Scheme 非常简单，通过 info.plist --&gt; URL Types --&gt; item0 --&gt; URL Schemes --&gt; 自定义的Scheme 来设置。 之后，在小组件中，即可通过 自定义的Scheme:// 拼接成的 URL 对象来打开自己的 App ，在 :// 后面可以增加参数来表明所需要功能或内容。 需要注意：增加参数时，出现的中文要进行转义。这里可以使用 NSURLComponents 和 NSURLQueryItem 来拼接跳转 URL 字符串。自带转义效果且操作 URL 更加规范。 NSURLComponents *components = [NSURLComponents componentsWithString:@&quot;自定义的Scheme://&quot;]; NSMutableArray&lt;NSURLQueryItem *&gt; *queryItems = @[].mutableCopy; NSURLQueryItem *aItem = [NSURLQueryItem queryItemWithName:@&quot;a&quot; value:@&quot;参数a&quot;]; [queryItems addObject:aItem]; NSURLQueryItem *bItem = [NSURLQueryItem queryItemWithName:@&quot;b&quot; value:@&quot;参数b&quot;]; [queryItems addObject:bItem]; components.queryItems = queryItems; NSURL *url = components.URL; 落地 App 后的处理 点击小组件跳转 App 后会触发 AppDelegate 的 openURL 方法。 - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options 在 openURL 方法中，通过解析 url 参数，明确用户需要的功能跳转或内容的展示，随后进行对应的实现。这对项目的路由能力提出了一定的要求，因和小组件开发联系不大，不做详述。 动态配置小组件 小组件支持用户在不打开应用的情况下配置自定义数据，使用 Intents 框架，可以定义用户在编辑小组件时看到的配置页面。 这里用的词的定义而不是绘制，是因为只能通过 Intents 来生成配置数据，系统会根据生成的数据来构建配置页面。 构建一个简单的自定义功能 构建一个简单的自定义功能需要两步： 创建和配置 IntentDefinition 文件 修改 Widget 的相关参数支持 ConfigurationIntent 。 1. 创建和配置 IntentDefinition 文件 如果你在创建小组件 Target 时勾选了 Include Configuration Intent ，Xcode 会自动生成 IntentDefinition 文件。 假如没有勾选 Include Configuration Intent 选项，那么你需要手动添加 IntentDefinition 文件。 菜单 File -&gt; New -&gt; File 然后找到 Siri Intent Definition File 之后添加到小组件 Target 中。 创建文件后，打开 .intentdefinition 文件进行配置。 首先需要记住左侧的 Custom Class 中的类名，Xcode 会根据这个名称，在编译后自动生成一个 ConfigurationIntent 类，这个类储存了用户配置信息。当然这里也可以填写一个你指定的类名，需要注意项目编译过后才会生成这个类。 然后我们需要创建自定义参数模板，点击Parameter 下方的 + 号即可创建一个参数。 之后可以定义创建出的 Parameter 的 Type ，除了相对直观的系统类型以外，还有两个比较难以理解的 Enums 和 Types 分栏。 系统类型 特定的类型有近一步的自定义选项来定制输入 UI。例如，Decimal 类型可以选择采用输入框（Number Field）输入或者是滑块（Slider）输入，同时可以定制输入的上下限；Duration 类型可以定制输入值的单位为秒、分或者时；Date Components 可以指定输入日期还是时间，指定日期的格式等等。 Enum 简单的理解就是 Enums 是写死在 .intentdefinition 文件中的静态配置，只有发版才可以更新。 Type Types 就灵活多了，可以在运行时动态的生成，一般而言我们使用 Types 来做自定义选项。 支持输入多个值 大部分类型的参数支持输入多个值，即输入一个数组。同时，支持根据不同的 Widget 大小，限制数组的固定长度。 控制配置项的显示条件 可以控制某一个配置项，只在另一个配置项含有任何/特定值时展示。如下图，日历 App 的 Up Next Widget，仅在 Mirror Calendar App 选项没有被选中时，才会显示 Calendars 配置项。 在 Intent 定义文件中，将某一个参数 A，设置为另一个参数 B 的 Parent Parameter ，这样，参数 B 的显示与否就取决于参数 A 的值。 例如，在下图中，calendar 参数仅在 mirrorCalendarApp 参数的值为 false 时展示： 2. 修改 Widget 的相关参数支持 ConfigurationIntent 替换 Widget 类中的 StaticConfiguration 为 IntentConfiguration 旧： @main struct MyWidget: Widget { let kind: String = &quot;MyWidget&quot; var body: some WidgetConfiguration { StaticConfiguration(kind: kind, provider: Provider()) { entry in MyWidgetEntryView(entry: entry) } } } 新： @main struct MyWidget: Widget { let kind: String = &quot;MyWidget&quot; var body: some WidgetConfiguration { IntentConfiguration(kind: kind, intent: WidgetConfiguratIntent.self, provider: Provider()) { entry in MyWidgetEntryView(entry: entry) } } } 在 Timeline Entry 类中增加 ConfigurationIntent 参数 代码如下： struct SimpleEntry: TimelineEntry { let date: Date let configuration: WidgetConfiguratIntent } 修改 IntentTimelineProvider 的继承 Provider 的继承改成 IntentTimelineProvider，并且增加 Intent 的类型别名。 旧： struct Provider: TimelineProvider { ... } 新： struct Provider: IntentTimelineProvider { typealias Intent = WidgetConfiguratIntent ... } 依次修改 getSnapshot / getTimeline 的入参以增加对自定义的支持。并在创建 Timeline Entry 时，传入 configuration 。 使用接口数据构建自定义入口 在 Intent Target 中，找到 IntentHandler 文件，遵守 ConfigurationIntent 生成类中 ConfiguratIntentHandling 协议。 实现协议要求的 provideModeArrOptionsCollectionForConfiguration:withCompletion: 方法。 在这个方法中，我们可以调用接口获取自定义数据，生成 completion block 所需要的数据源入参。 - (void)provideModeArrOptionsCollectionForConfiguration:(WidgetConfiguratIntent *)intent withCompletion:(void (^)(INObjectCollection&lt;NMWidgetModel *&gt; * _Nullable modeArrOptionsCollection, NSError * _Nullable error))completion { [self apiRequest:(NSDictionary *result){ // 处理获取到的数据 .... NSMutableArray *allModelArr = ....; // 生成配置所需要的数据 INObjectCollection *collection = [[INObjectCollection alloc] initWithItems:allModeArr]; completion(collection,nil); }]; } 小组件获取自定义参数 在小组件根据 Timeline Entry 生成视图时，读取 Entry 的 configuration 属性即可获取用户是否自定义属性，以及自定义属性的详细值。 总结 优势和缺点并存 小组件是一个优缺点都非常明显的事物，在桌面即点即用确实方便，但是交互方式的匮乏以及不能实时更新数据又是非常大的缺陷。正如苹果所说：&quot;Widgets are not mini-apps&quot;，不要用开发 App 的思维来做小组件，小组件只是由一连串数据驱动的静态视图。 优势： 常驻桌面，大大增加了对产品的曝光。 利用网络接口和数据共享，可以展示与用户相关的个性化内容。 缩短了功能的访问路径。一次点击即可让用户触达所需功能。 可以多次重复添加，搭配自定义和推荐算法，添加多个小组件样式和数据都可以不同。 自定义配置简单。 多种尺寸，大尺寸可以承载复杂度高的内容展示。 缺点： 不能实时更新数据。 只能点击交互。 小组件的背景不能设置透明效果。 不能展示动态图像（视频/动图）。 尾巴 小组件的开发实践到此告一段落，可以看到组件虽小，需要的知识还是挺多的。包括 Timeline 、Intents 、SwiftUI 等平时开发很难接触到的框架和概念需要了解学习。 小组件孱弱的交互能力和数据刷新机制是它的硬伤。苹果对于小组件的能力是非常克制的。在开发中，很多构思和需求都受限于框架能力无法实现，希望苹果在后续迭代中可以开放出新的能力。比如支持部分不需要启动 App 的交互形式存在。 但瑕不掩瑜，向用户展示喜欢的内容或提供用户想要的功能入口，放大小组件的优势，才是当前小组件的正确开发方式。 参考资料 认识小组件 Widgets 边看边写-1 Widgets 边看边写-2 Widgets 边看边写-3 使你的 Widget 支持个性化配置 &amp; 智能化展现 从开发者的角度看 iOS 14 小组件 【十五分钟搞懂SwiftUI】布局篇 【十五分钟搞懂SwiftUI】样式篇 ","link":"https://www.yiios.com/post/wang-yi-yun-yin-le-ios-14-xiao-zu-jian-shi-zhan-shou-ce/"}]}